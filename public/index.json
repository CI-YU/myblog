[{"content":"Ha Today is a good day ","permalink":"https://ci-yu.top/posts/first/","summary":"Ha Today is a good day ","title":"First"},{"content":"目的 在windows系統上想執行排程有兩個選擇\n使用windows工作排程器執行exe檔 透過Hangfire進行排程管理 此次教學說明如何使用Hangfire執行排程\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Hangfire Hangfire.InMemory 編輯Program.cs檔 using Hangfire; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊hangfire並且使用記憶體保存排程， //預設所下載的HangFire套件可以使用sqlserver，可透過config.UseSqlServerStorage();，但需要設定 builder.Services.AddHangfire(config =\u0026gt; { config.UseInMemoryStorage(); }); //註冊hangfire要使用的伺服器，伺服器就是上面所寫的使用記憶體當伺服器 builder.Services.AddHangfireServer(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); //使用hangfire內建的儀表板 app.UseHangfireDashboard(); app.MapControllers(); app.Run(); 編輯WeatherForecastController.cs類別檔 //記得using Hangfire; [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //單次立即執行 BackgroundJob.Enqueue(() =\u0026gt; Console.WriteLine(\u0026#34;單次!\u0026#34;)); //單次10秒後執行 BackgroundJob.Schedule(() =\u0026gt; Console.WriteLine(\u0026#34;10秒後執行!\u0026#34;), TimeSpan.FromSeconds(10)); //重複執行，預設為每天00:00啟動 RecurringJob.AddOrUpdate(() =\u0026gt; Console.WriteLine(\u0026#34;重複執行！\u0026#34;), Cron.Daily); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } 執行結果 F5執行後，依照下列步驟操作，並確認結果 接下來到hangfire儀表板查看執行狀態\n預設的網址為https://domain/hangfire 我的swagger網址為 https://localhost:7198/swagger/index.html 所以下方為hangfire預設路徑 https://localhost:7198/hangfire\n就可以看到Hangfire的畫面了，接著點擊上方工作就可以看到所執行的排程，如需看重複作業則點選定期工作 後記 任務排程的套件還有另外兩個Coravel與Quart.Net都可以參考看看\n參考 Hangfire官網\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-hangfire%E7%AF%84%E4%BE%8B/","summary":"目的 在windows系統上想執行排程有兩個選擇\n使用windows工作排程器執行exe檔 透過Hangfire進行排程管理 此次教學說明如何使用Hangfire執行排程\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Hangfire Hangfire.InMemory 編輯Program.cs檔 using Hangfire; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊hangfire並且使用記憶體保存排程， //預設所下載的HangFire套件可以使用sqlserver，可透過config.UseSqlServerStorage();，但需要設定 builder.Services.AddHangfire(config =\u0026gt; { config.UseInMemoryStorage(); }); //註冊hangfire要使用的伺服器，伺服器就是上面所寫的使用記憶體當伺服器 builder.Services.AddHangfireServer(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); //使用hangfire內建的儀表板 app.UseHangfireDashboard(); app.","title":"2022ITHelp dotnet6 Hangfire範例"},{"content":"目的 面試的時候被問到要如何做包含外部api的單元測試問題，稍微查一下其實很簡單，怎麼當下答不出來呢? 主要有兩種方式，一種為.net core 2.1以後有提供IHttpClientFactory的介面可以使用。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立資料夾 編輯Program.cs檔案 註冊AddHttpClient。\nbuilder.Services.AddHttpClient(); 新增一個類別檔 加入前 加入後 建構子注入 將註冊的httpclient透過建構子注入\nreadonly IHttpClientFactory _httpClientFactory;\rpublic CallAPIServices(IHttpClientFactory httpClientFactory) {\r_httpClientFactory = httpClientFactory;\r} 加入前 加入後 新增方法 新增一個會去發外部請求的方法，模擬當有包含第三方api時如何測試\npublic async Task\u0026lt;string\u0026gt; Get() {\rvar client = _httpClientFactory.CreateClient();\rvar response = await client.GetAsync(\u0026#34;https://example.com\u0026#34;);\rif (response.IsSuccessStatusCode) {\rvar responseString = await response.Content.ReadAsStringAsync();\rreturn responseString;\r}\rreturn \u0026#34;\u0026#34;;\r} 新增測試專案 對方案點選右鍵\u0026gt;加入\u0026gt;新增專案\n設定新的專案 替測試專案命名，建議命名規則以.Tests做結尾 其他資訊 專案架構需要與要測試的專案相同 加入參考 將要測試的專案加入測試專案\n對CallAPIServices.Tests點選右鍵\u0026gt;加入\u0026gt;專案參考\nNuGet加入套件 透過NuGet安裝Moq套件至測試專案 新增對應資料夾與測試檔案 新增檔案，檔名需要與要測試的檔案一致，並加上Tests 新增程式碼 在新增的檔案內新增一個方法並寫入程式碼，一開始會看到許多紅色波浪，是因為沒有加入參考\n//定義這個方法是不需要傳入參數的單元測試，另一種為[Theory]，詳細說明可看相關參考5 [Fact] //命名規則 =\u0026gt; 類別名稱_方法名稱_要測試的方法行為_回傳狀態 public async Task CallAPIServices_Get_HttpClient_Success() { //模擬出一個IHttpClientFactory的假物件 var mockFactory = new Mock\u0026lt;IHttpClientFactory\u0026gt;(); //產生http回傳的實例 HttpResponseMessage result = new HttpResponseMessage() { StatusCode = HttpStatusCode.OK, Content = new StringContent(\u0026#34;{\u0026#39;account\u0026#39;:\u0026#39;bill\u0026#39;,\u0026#39;age\u0026#39;:18}\u0026#34;) }; //模擬出一個http處理程序的基本類型實例的假物件 var mockHttpMessageHandler = new Mock\u0026lt;HttpMessageHandler\u0026gt;(); //模擬http發出請求後所做的一連串事情，最後並回傳結果 //protected =\u0026gt; 發出請求的方法SendAsync是一個protected存取修飾詞，不能直接存取，所以告訴moq請幫忙執行protected方法，詳細說明可看參考6 //Setup =\u0026gt; 設定此執行動作為SendAsync方法，並需要兩個傳入參數，HttpRequestMessage與CancellationToken //ItExpr.IsAny =\u0026gt; 請moq協助傳入一個參數為HttpRequestMessage與CancellationToken的假參數，另一種為It.IsAny是非protected方法使用 //ReturnsAsync =\u0026gt; 回傳非同步的值 mockHttpMessageHandler.Protected() .Setup\u0026lt;Task\u0026lt;HttpResponseMessage\u0026gt;\u0026gt;(\u0026#34;SendAsync\u0026#34;, ItExpr.IsAny\u0026lt;HttpRequestMessage\u0026gt;(), ItExpr.IsAny\u0026lt;CancellationToken\u0026gt;()) .ReturnsAsync(result); //將製作好的假請求與回傳給HttpClient var client = new HttpClient(mockHttpMessageHandler.Object); //模擬實際請求，並接收到我們所製作的假物件 mockFactory.Setup(_ =\u0026gt; _.CreateClient(It.IsAny\u0026lt;string\u0026gt;())).Returns(client); //將製作好的完整請求流程給我們在使用的方法 var services = new HttpclientExample.Services.CallAPIServices(mockFactory.Object); //執行要測試的方法 var response = await services.Get(); //回傳值不能為null Assert.NotNull(response); //回傳值必須一致 Assert.Equal(\u0026#34;{\u0026#39;account\u0026#39;:\u0026#39;bill\u0026#39;,\u0026#39;age\u0026#39;:18}\u0026#34;, response); } 加入前 加入後 執行測試 點右鍵執行測試，最後結果會如左下角顯示成功 相關參考 單元測試好的做法 為什麼要使用IHttpClientFactory moq套件介紹 單元測試介紹 Fact跟Theory差別 存取修飾詞\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-httpclient%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E7%AF%84%E4%BE%8B/","summary":"目的 面試的時候被問到要如何做包含外部api的單元測試問題，稍微查一下其實很簡單，怎麼當下答不出來呢? 主要有兩種方式，一種為.net core 2.1以後有提供IHttpClientFactory的介面可以使用。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立資料夾 編輯Program.cs檔案 註冊AddHttpClient。\nbuilder.Services.AddHttpClient(); 新增一個類別檔 加入前 加入後 建構子注入 將註冊的httpclient透過建構子注入\nreadonly IHttpClientFactory _httpClientFactory;\rpublic CallAPIServices(IHttpClientFactory httpClientFactory) {\r_httpClientFactory = httpClientFactory;\r} 加入前 加入後 新增方法 新增一個會去發外部請求的方法，模擬當有包含第三方api時如何測試\npublic async Task\u0026lt;string\u0026gt; Get() {\rvar client = _httpClientFactory.CreateClient();\rvar response = await client.GetAsync(\u0026#34;https://example.com\u0026#34;);\rif (response.IsSuccessStatusCode) {\rvar responseString = await response.Content.ReadAsStringAsync();\rreturn responseString;\r}\rreturn \u0026#34;\u0026#34;;\r} 新增測試專案 對方案點選右鍵\u0026gt;加入\u0026gt;新增專案\n設定新的專案 替測試專案命名，建議命名規則以.Tests做結尾 其他資訊 專案架構需要與要測試的專案相同 加入參考 將要測試的專案加入測試專案","title":"2022ITHelp dotnet6 HttpClient單元測試範例"},{"content":"目的 進行單元測試時，可以隔絕依賴的項目。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成MoqExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector Moq 針對MoqExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增WeatherForecastControllerTests.cs類別檔 刪除預設的類別檔(Class1.cs)，並在MoqExample.Tests專案新增對應資料夾，與類別檔並加結尾Tests。 編輯WeatherForecastControllerTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 這次要測試的是controller，有注入Ilogger，如何將Ilogger隔開的關鍵就是使用Moq這個套件 using Microsoft.Extensions.Logging; using Moq; using MoqExample.Controllers; using Xunit; namespace MoqExample.Tests.Controllers { public class WeatherForecastControllerTests { [Fact] public void Get() { //Arrange //透過mock將外界的介面包起來 var MockLogger = new Mock\u0026lt;ILogger\u0026lt;WeatherForecastController\u0026gt;\u0026gt;(); //當成物件傳入controller，代替實際的介面 var Controllers = new WeatherForecastController(MockLogger.Object); //Act //執行要測試的函式 var Results = Controllers.Get(); //Assert //確認結果不為null Assert.NotNull(Results); //確認結果數量等於5 Assert.Equal(5, Results.Count()); } } } 執行結果 點選測試\u0026gt;執行所有測試\n下方視窗就會顯示成功或失敗 參考 Moq-Quickstart\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-moq%E7%AF%84%E4%BE%8B/","summary":"目的 進行單元測試時，可以隔絕依賴的項目。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成MoqExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector Moq 針對MoqExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增WeatherForecastControllerTests.cs類別檔 刪除預設的類別檔(Class1.cs)，並在MoqExample.Tests專案新增對應資料夾，與類別檔並加結尾Tests。 編輯WeatherForecastControllerTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 這次要測試的是controller，有注入Ilogger，如何將Ilogger隔開的關鍵就是使用Moq這個套件 using Microsoft.Extensions.Logging; using Moq; using MoqExample.Controllers; using Xunit; namespace MoqExample.Tests.Controllers { public class WeatherForecastControllerTests { [Fact] public void Get() { //Arrange //透過mock將外界的介面包起來 var MockLogger = new Mock\u0026lt;ILogger\u0026lt;WeatherForecastController\u0026gt;\u0026gt;(); //當成物件傳入controller，代替實際的介面 var Controllers = new WeatherForecastController(MockLogger.Object); //Act //執行要測試的函式 var Results = Controllers.Get(); //Assert //確認結果不為null Assert.","title":"2022ITHelp dotnet6 Moq範例"},{"content":"目的 在寫nlog.config檔案時覺得怎麼有點複雜，我只是需要簡單的設定檔就好了，最後決定透過appsetting來做設定 將log文件採用非同步寫入，可大幅提升效能 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 4.NuGet加入套件 NLog NLog.Web.AspNetCore 編輯Program.cs檔 using NLog; using NLog.Web; //初始化NLog var logger = LogManager.Setup() //載入Configuration並且讀取appsetting來使用 .LoadConfigurationFromAppSettings() .GetCurrentClassLogger(); try { logger.Debug(\u0026#34;init main\u0026#34;); var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Logging.ClearProviders(); builder.Host.UseNLog(); builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //以下省略 編輯appsetting.json 設定NLog，包含\nthrowConfigExceptions:設定檔錯誤時會跳exception 使用非同步方式寫入檔案 targets:設定輸出的格式，例如txt檔案或是Console顯示 rules:什麼情況要做什麼動作，例如log名稱為Microsoft.AspNetCore最小等級是warn時寫到Console ILogger NLog Level 0 Trace Trace Level 1 Debug Debug Level 2 Information Info Level 3 Warning Warn Level 4 Error Error Level 5 Critical Fatal Level 6 None NLog沒有 { \u0026#34;NLog\u0026#34;: { \u0026#34;throwConfigExceptions\u0026#34;: true, \u0026#34;targets\u0026#34;: { \u0026#34;async\u0026#34;: true, \u0026#34;logfile\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;File\u0026#34;, \u0026#34;fileName\u0026#34;: \u0026#34;c:/temp/nlog-${shortdate}.txt\u0026#34; }, \u0026#34;logconsole\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Console\u0026#34; } }, \u0026#34;rules\u0026#34;: [ { \u0026#34;logger\u0026#34;: \u0026#34;Microsoft.AspNetCore\u0026#34;, \u0026#34;minLevel\u0026#34;: \u0026#34;Warn\u0026#34;, \u0026#34;writeTo\u0026#34;: \u0026#34;logconsole\u0026#34; }, { \u0026#34;logger\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;minLevel\u0026#34;: \u0026#34;Info\u0026#34;, \u0026#34;writeTo\u0026#34;: \u0026#34;logfile\u0026#34; } ] } } 編輯WeatherForecastController.cs類別檔 [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //新增一個類型 var StudentObject = new Student() { Id = 4, Name = \u0026#34;Bill\u0026#34;, Age = 20 }; //新增一個匿名類型 var position = new { Latitude = 25, Longitude = 134 }; //寫log等級為error的log，當需要紀錄物件時需要透過{@該物件}來表示 _logger.LogError(\u0026#34;Error Value: {@StudentObject}\u0026#34;, StudentObject); _logger.LogError(\u0026#34;Error Value: {@position}\u0026#34;, position); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } public class Student { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果 執行後查看log檔案，這次寫到C:\\temp底下 第一個紅框處顯示物件內容 第二個紅框處顯示使用Get請求呼叫了WeatherForecast回傳狀態碼200用了54.3ms的時間 結論 最後其實會發現Serilog相對來說比較容易使用，也建議使用serilog\n參考 黑暗執行緒 中文輸出為unicode問題 target參數中文解說 非同步使用方式與縮寫\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-nlog%E9%80%B2%E9%9A%8E%E7%AF%84%E4%BE%8B/","summary":"目的 在寫nlog.config檔案時覺得怎麼有點複雜，我只是需要簡單的設定檔就好了，最後決定透過appsetting來做設定 將log文件採用非同步寫入，可大幅提升效能 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 4.NuGet加入套件 NLog NLog.Web.AspNetCore 編輯Program.cs檔 using NLog; using NLog.Web; //初始化NLog var logger = LogManager.Setup() //載入Configuration並且讀取appsetting來使用 .LoadConfigurationFromAppSettings() .GetCurrentClassLogger(); try { logger.Debug(\u0026#34;init main\u0026#34;); var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Logging.ClearProviders(); builder.Host.UseNLog(); builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //以下省略 編輯appsetting.json 設定NLog，包含\nthrowConfigExceptions:設定檔錯誤時會跳exception 使用非同步方式寫入檔案 targets:設定輸出的格式，例如txt檔案或是Console顯示 rules:什麼情況要做什麼動作，例如log名稱為Microsoft.AspNetCore最小等級是warn時寫到Console ILogger NLog Level 0 Trace Trace Level 1 Debug Debug Level 2 Information Info Level 3 Warning Warn Level 4 Error Error Level 5 Critical Fatal Level 6 None NLog沒有 { \u0026#34;NLog\u0026#34;: { \u0026#34;throwConfigExceptions\u0026#34;: true, \u0026#34;targets\u0026#34;: { \u0026#34;async\u0026#34;: true, \u0026#34;logfile\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;File\u0026#34;, \u0026#34;fileName\u0026#34;: \u0026#34;c:/temp/nlog-${shortdate}.","title":"2022ITHelp dotnet6 NLog進階範例"},{"content":"目的 單元測試\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成xUnitExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector 新增Calculator.cs類別檔 在xUnitExample專案新增Calculator.cs類別檔 新增一個簡單的加法函式\npublic static class Calculator { public static double Add(int a, int b) { return a + b; } } 針對xUnitExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增CalculatorTests.cs類別檔 刪除預設的類別檔(Class1.cs)，建立對應的資料夾以及類別檔案，並在結尾加上Tests 編輯CalculatorTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 public class CalculatorTests { //告訴編譯器要執行的測試方法 [Fact] public void Add_() { //Arrange double Expected = 20; //Act var Actual = Calculator.Add(5, 15); //Assert Assert.Equal(Expected, Actual); } } 執行結果 點選測試\u0026gt;執行所有測試\n下方視窗就會顯示成功或失敗 後記 單元測試有另外兩種NUnit與mstest，基本上大同小異，並無太大的區別。\n參考 xUnit官網 該用什麼Packages\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-xunit%E7%AF%84%E4%BE%8B/","summary":"目的 單元測試\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成xUnitExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector 新增Calculator.cs類別檔 在xUnitExample專案新增Calculator.cs類別檔 新增一個簡單的加法函式\npublic static class Calculator { public static double Add(int a, int b) { return a + b; } } 針對xUnitExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增CalculatorTests.cs類別檔 刪除預設的類別檔(Class1.cs)，建立對應的資料夾以及類別檔案，並在結尾加上Tests 編輯CalculatorTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 public class CalculatorTests { //告訴編譯器要執行的測試方法 [Fact] public void Add_() { //Arrange double Expected = 20; //Act var Actual = Calculator.Add(5, 15); //Assert Assert.","title":"2022ITHelp dotnet6 xUnit範例"},{"content":"目的 在webapi專案下使用NLog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 NLog NLog.Web.AspNetCore 新增nlog.config檔案 在根目錄新增nlog.config檔案 nlog.config寫入程式 在nlog.config寫入官方範例\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt;\r\u0026lt;nlog xmlns=\u0026#34;http://www.nlog-project.org/schemas/NLog.xsd\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rautoReload=\u0026#34;true\u0026#34;\rinternalLogLevel=\u0026#34;Info\u0026#34;\rinternalLogFile=\u0026#34;c:\\temp\\internal-nlog-AspNetCore.txt\u0026#34;\u0026gt;\r\u0026lt;!-- enable asp.net core layout renderers --\u0026gt;\r\u0026lt;extensions\u0026gt;\r\u0026lt;add assembly=\u0026#34;NLog.Web.AspNetCore\u0026#34;/\u0026gt;\r\u0026lt;/extensions\u0026gt;\r\u0026lt;!-- the targets to write to --\u0026gt;\r\u0026lt;targets\u0026gt;\r\u0026lt;!-- File Target for all log messages with basic details --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;allfile\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-all-${shortdate}.log\u0026#34;\rlayout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}\u0026#34; /\u0026gt;\r\u0026lt;!-- File Target for own log messages with extra web details using some ASP.NET core renderers --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;ownFile-web\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-own-${shortdate}.log\u0026#34;\rlayout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}|url: ${aspnet-request-url}|action: ${aspnet-mvc-action}|${callsite}\u0026#34; /\u0026gt;\r\u0026lt;!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;Console\u0026#34; name=\u0026#34;lifetimeConsole\u0026#34; layout=\u0026#34;${MicrosoftConsoleLayout}\u0026#34; /\u0026gt;\r\u0026lt;/targets\u0026gt;\r\u0026lt;!-- rules to map from logger name to target --\u0026gt;\r\u0026lt;rules\u0026gt;\r\u0026lt;!--All logs, including from Microsoft--\u0026gt;\r\u0026lt;logger name=\u0026#34;*\u0026#34; minlevel=\u0026#34;Trace\u0026#34; writeTo=\u0026#34;allfile\u0026#34; /\u0026gt;\r\u0026lt;!--Output hosting lifetime messages to console target for faster startup detection --\u0026gt;\r\u0026lt;logger name=\u0026#34;Microsoft.Hosting.Lifetime\u0026#34; minlevel=\u0026#34;Info\u0026#34; writeTo=\u0026#34;lifetimeConsole, ownFile-web\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt;\r\u0026lt;!--Skip non-critical Microsoft logs and so log only own logs (BlackHole) --\u0026gt;\r\u0026lt;logger name=\u0026#34;Microsoft.*\u0026#34; maxlevel=\u0026#34;Info\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt;\r\u0026lt;logger name=\u0026#34;System.Net.Http.*\u0026#34; maxlevel=\u0026#34;Info\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt;\r\u0026lt;logger name=\u0026#34;*\u0026#34; minlevel=\u0026#34;Trace\u0026#34; writeTo=\u0026#34;ownFile-web\u0026#34; /\u0026gt;\r\u0026lt;/rules\u0026gt;\r\u0026lt;/nlog\u0026gt; 只擷取部分畫面 Program寫入程式 在Program寫入官方範例\nusing NLog;\rusing NLog.Web;\rvar logger = LogManager.Setup().LoadConfigurationFromAppSettings().GetCurrentClassLogger();\rlogger.Debug(\u0026#34;init main\u0026#34;);\rtry {\rvar builder = WebApplication.CreateBuilder(args);\r//將NLog註冊到此專案內\rbuilder.Logging.ClearProviders();\r//設定log紀錄的最小等級\rbuilder.Logging.SetMinimumLevel(Microsoft.Extensions.Logging.LogLevel.Information);\rbuilder.Host.UseNLog();\rbuilder.Services.AddControllers();\r// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\rbuilder.Services.AddEndpointsApiExplorer();\rbuilder.Services.AddSwaggerGen();\rvar app = builder.Build();\r// Configure the HTTP request pipeline.\rif (app.Environment.IsDevelopment()) {\rapp.UseSwagger();\rapp.UseSwaggerUI();\r}\rapp.UseHttpsRedirection();\rapp.UseAuthorization();\rapp.MapControllers();\rapp.Run();\r} catch (Exception ex) {\r// 捕獲設定錯誤的錯誤紀錄\rlogger.Error(ex, \u0026#34;Stopped program because of exception\u0026#34;);\rthrow;\r} finally {\r//須確定在關閉時，把nlog關閉\rLogManager.Shutdown();\r} 只擷取部分畫面 設定appsetting.json 將原先存在的default移除\n{\r\u0026#34;Logging\u0026#34;: {\r\u0026#34;LogLevel\u0026#34;: {\r\u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34;\r}\r},\r\u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;\r} controller寫入log 在預設的controller裡面寫入Log，如下圖紅框處\n//寫在建構子內\r_logger.LogDebug(1, \u0026#34;NLog injected into HomeController\u0026#34;);\r//寫在action內\r_logger.LogInformation(\u0026#34;這是範例程式預設的controller!!\u0026#34;); 執行結果 點try it out後點execute，確定執行完成查看console檔案(執行專案會啟動一個terminal) 步驟六有在設定檔內設定log存放路徑，c:\\temp\\internal-nlog-AspNetCore.txt 結論 完成範例說明後建議使用Serilog，因為相對來說單純一點，對於設定上來說nlog真的比較複雜。\n參考 官方範例\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-nlog%E7%AF%84%E4%BE%8B/","summary":"目的 在webapi專案下使用NLog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 NLog NLog.Web.AspNetCore 新增nlog.config檔案 在根目錄新增nlog.config檔案 nlog.config寫入程式 在nlog.config寫入官方範例\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt;\r\u0026lt;nlog xmlns=\u0026#34;http://www.nlog-project.org/schemas/NLog.xsd\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rautoReload=\u0026#34;true\u0026#34;\rinternalLogLevel=\u0026#34;Info\u0026#34;\rinternalLogFile=\u0026#34;c:\\temp\\internal-nlog-AspNetCore.txt\u0026#34;\u0026gt;\r\u0026lt;!-- enable asp.net core layout renderers --\u0026gt;\r\u0026lt;extensions\u0026gt;\r\u0026lt;add assembly=\u0026#34;NLog.Web.AspNetCore\u0026#34;/\u0026gt;\r\u0026lt;/extensions\u0026gt;\r\u0026lt;!-- the targets to write to --\u0026gt;\r\u0026lt;targets\u0026gt;\r\u0026lt;!-- File Target for all log messages with basic details --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;allfile\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-all-${shortdate}.log\u0026#34;\rlayout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}\u0026#34; /\u0026gt;\r\u0026lt;!-- File Target for own log messages with extra web details using some ASP.","title":"2022ITHelp dotnet6 NLog範例"},{"content":"目的 讀取appsetting設定檔 二階段初始化 為了簡單化故將Log存入SQLite 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore Serilog.Sinks.SQLite 編輯Program.cs檔 using Serilog; //第一階段初始化 // var builder = WebApplication.CreateBuilder(args);未使用二階段參數化，builder會跑到try外面 Log.Logger = new LoggerConfiguration() //.ReadFrom.Configuration(builder.Configuration) .CreateBootstrapLogger(); try { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //第二階段初始化可以取得appsetting的內容，如不使用第二階段初始化， //會需要將 var builder宣告式會移出try(如上方註解處)，就會有風險未捕獲builder的錯誤 builder.Host.UseSerilog( (hostingContext, services, loggerConfiguration) =\u0026gt; { //使用appsetting loggerConfiguration.ReadFrom.Configuration(builder.Configuration); }); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); //紀錄每個Request的資料，須注意要放在讀取靜態檔案(app.UseStaticFiles())後面，因為靜態檔案的狀態通常不需要紀錄資訊 app.UseSerilogRequestLogging(); //以下省略 編輯appsetting.json 設定Serilog，包含\n最低紀錄標準為Information Microsoft.AspNetCore開頭類別紀錄標準為Warning 寫Log檔到console 寫Log檔到File，並請用日期分割檔案 寫Log檔到SQLite，資料表名稱為Logs，限制DB最大為1M，預設還有一個參數rollOver為true，當達到限制，就會分割DB { \u0026#34;Serilog\u0026#34;: { \u0026#34;MinimumLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Override\u0026#34;: { \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;WriteTo\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;Console\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;File\u0026#34;, \u0026#34;Args\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;./logs/log-.txt\u0026#34;, \u0026#34;rollingInterval\u0026#34;: \u0026#34;Day\u0026#34; } }, { \u0026#34;Name\u0026#34;: \u0026#34;SQLite\u0026#34;, \u0026#34;Args\u0026#34;: { \u0026#34;sqliteDbPath\u0026#34;: \u0026#34;../../../logs/log.sqlite\u0026#34;, \u0026#34;tableName\u0026#34;: \u0026#34;Logs\u0026#34;, \u0026#34;maxDatabaseSize\u0026#34;: 1 } } ] }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } 編輯WeatherForecastController.cs類別檔 [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //新增一個類型 var StudentObject = new Student() { Id = 4, Name = \u0026#34;Bill\u0026#34;, Age = 20 }; //新增一個匿名類型 var position = new { Latitude = 25, Longitude = 134 }; //寫log等級為error的log，當需要紀錄物件時需要透過{@該物件}來表示 _logger.LogError(\u0026#34;Error Value: {@StudentObject}\u0026#34;, StudentObject); _logger.LogError(\u0026#34;Error Value: {@position}\u0026#34;, position); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } public class Student { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果 執行後查看Log檔 點擊txt檔案後會看到我們所寫的Log檔案，會發現\n第一個紅框處非匿名類型多一個$type跟你說明是什麼類型 第二個紅框處是由於在Program.cs加入了app.UseSerilogRequestLogging();會記錄使用Get請求呼叫了WeatherForecast回傳狀態碼200用了31ms的時間 參考 Serilog m@rcus 學習筆記\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-serilog%E9%80%B2%E9%9A%8E%E7%AF%84%E4%BE%8B/","summary":"目的 讀取appsetting設定檔 二階段初始化 為了簡單化故將Log存入SQLite 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore Serilog.Sinks.SQLite 編輯Program.cs檔 using Serilog; //第一階段初始化 // var builder = WebApplication.CreateBuilder(args);未使用二階段參數化，builder會跑到try外面 Log.Logger = new LoggerConfiguration() //.ReadFrom.Configuration(builder.Configuration) .CreateBootstrapLogger(); try { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //第二階段初始化可以取得appsetting的內容，如不使用第二階段初始化， //會需要將 var builder宣告式會移出try(如上方註解處)，就會有風險未捕獲builder的錯誤 builder.Host.UseSerilog( (hostingContext, services, loggerConfiguration) =\u0026gt; { //使用appsetting loggerConfiguration.ReadFrom.Configuration(builder.Configuration); }); var app = builder.","title":"2022ITHelp dotnet6 Serilog進階範例"},{"content":"目的 在webapi專案下使用serilog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore 編輯Program.cs檔 在最外層包一個try catch目的是為了捕捉啟動階段的錯誤\nusing Serilog; using Serilog.Events; Log.Logger = new LoggerConfiguration() //Serilog要寫入的最低等級為Information .MinimumLevel.Information() //Microsoft.AspNetCore開頭的類別等極為warning .MinimumLevel.Override(\u0026#34;Microsoft.AspNetCore\u0026#34;, LogEventLevel.Warning) //寫log到Logs資料夾的log.txt檔案中，並且以天為單位做檔案分割 .WriteTo.File(\u0026#34;./Logs/log.txt\u0026#34;, rollingInterval: RollingInterval.Day) .CreateLogger(); try { Log.Information(\u0026#34;Starting web host\u0026#34;); var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //controller可以使用ILogger介面來寫入log紀錄 builder.Host.UseSerilog(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); return 0; } catch (Exception ex) { Log.Fatal(ex, \u0026#34;Host terminated unexpectedly\u0026#34;); return 1; } finally { Log.CloseAndFlush(); } 編輯WeatherForecastController.cs類別檔 因預設就有注入ILogger，故可以直接使用\n因微軟內建的介面ILogger等級區分與Serilog不一樣，故提供對照表格\nILogger Serilog Level 0 Trace Verbose Level 1 Debug Debug Level 2 Information Information Level 3 Warning Warning Level 4 Error Error Level 5 Critical Fatal Level 6 None Serilog沒有 private readonly ILogger\u0026lt;WeatherForecastController\u0026gt; _logger; public WeatherForecastController(ILogger\u0026lt;WeatherForecastController\u0026gt; logger) { _logger = logger; } [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //輸出log _logger.LogInformation(\u0026#34;This is Controller\u0026#34;); _logger.LogError(\u0026#34;Test Error\u0026#34;); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } 執行結果 F5執行後，依照下列步驟操作，並確認結果 執行後就可以到我們的專案檔路徑下查看Logs資料夾 點進去資料夾後就可以看到以日期為單位的txt檔案 參考 余小章 Will保哥 官方文件\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-serilog%E7%AF%84%E4%BE%8B/","summary":"目的 在webapi專案下使用serilog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore 編輯Program.cs檔 在最外層包一個try catch目的是為了捕捉啟動階段的錯誤\nusing Serilog; using Serilog.Events; Log.Logger = new LoggerConfiguration() //Serilog要寫入的最低等級為Information .MinimumLevel.Information() //Microsoft.AspNetCore開頭的類別等極為warning .MinimumLevel.Override(\u0026#34;Microsoft.AspNetCore\u0026#34;, LogEventLevel.Warning) //寫log到Logs資料夾的log.txt檔案中，並且以天為單位做檔案分割 .WriteTo.File(\u0026#34;./Logs/log.txt\u0026#34;, rollingInterval: RollingInterval.Day) .CreateLogger(); try { Log.Information(\u0026#34;Starting web host\u0026#34;); var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //controller可以使用ILogger介面來寫入log紀錄 builder.Host.UseSerilog(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); return 0; } catch (Exception ex) { Log.","title":"2022ITHelp dotnet6 Serilog範例"},{"content":"目的 說明EFCore基本語法，EFCore的基礎為Linq，所以使用上與Linq邏輯一模一樣，只是語法有些微差異。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample_Advanced.Models; namespace EFCoreExample_Advanced.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.UseSqlite(\u0026#34;Data Source=Student.sqlite\u0026#34;); } //設定student資料表 public DbSet\u0026lt;Student\u0026gt; Students { get; set; } } } 編輯Program.cs檔 //別忘了using using EFCoreExample_Advanced.DBContext; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊EFCoreContext builder.Services.AddDbContext\u0026lt;EFCoreContext\u0026gt;(); //下面省略 到套件管理器主控台下Terminal指令 檢視\u0026gt;其他視窗\u0026gt;套件管理器主控台 下方會出現命令列 輸入dir會顯示目錄檔案及子目錄清單 輸入cd EFCoreExample_Advanced移動到專案檔底下後再輸入dir確認是否到正確路徑 輸入dotnet tool install --global dotnet-ef在全域安裝EFCore CLI工具(如果已經安裝，會出現下圖訊息，即可忽略此步驟) 輸入dotnet ef migrations add CreateInitial初始化SQLite 輸入dotnet ef database update更新SQLite資料表 成功就會自動產生Migrations資料夾 編輯WeatherForecastController檔案編輯 寫新的對外API：QueryAsync [HttpGet(\u0026#34;QueryAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryAsync() { //透過ToListAsync方法就可以將Students所有資料取出 var Result = await _context.Students.ToListAsync(); return Ok(Result); } 寫新的對外API：QueryFirstOrDefaultAsync [HttpGet(\u0026#34;QueryFirstOrDefaultAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryFirstOrDefaultAsync() { //取得第一筆 var Result = await _context.Students.FirstOrDefaultAsync(); return Ok(Result); } 交易機制 當有多張表需要異動時，為了確認資料的一致性，會需要透過交易機制做保護，只有全部成功或全部失敗。 [HttpGet(\u0026#34;TransactionsAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; TransactionsAsync() { //開始資料庫交易 using var trans = _context.Database.BeginTransaction(); //建立一筆資料 var data = new Student() { Name = \u0026#34;BillHuang\u0026#34;, Age = 20 }; //新增到Students資料表中 _context.Students.Add(data); //執行，此步驟還不會真的異動到資料 await _context.SaveChangesAsync(); //取得第一筆資料 var Result = await _context.Students.FirstOrDefaultAsync(); //當執行了Commit後才會將上面的異動存到資料庫 trans.Commit(); return Ok(Result); } 參考 N+1 交易\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-efcore%E8%AA%9E%E6%B3%95%E8%AA%AA%E6%98%8E/","summary":"目的 說明EFCore基本語法，EFCore的基礎為Linq，所以使用上與Linq邏輯一模一樣，只是語法有些微差異。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample_Advanced.Models; namespace EFCoreExample_Advanced.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.","title":"2022ITHelp dotnet6 EFCore語法說明"},{"content":"目的 透過EFCore對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample.Models; namespace EFCoreExample.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.UseSqlite(\u0026#34;Data Source=Student.sqlite\u0026#34;); } //設定student資料表 public DbSet\u0026lt;Student\u0026gt; Students { get; set; } } } 編輯Program.cs檔 //別忘了using using EFCoreExample.DBContext; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊EFCoreContext builder.Services.AddDbContext\u0026lt;EFCoreContext\u0026gt;(); //下面省略 到套件管理器主控台下Terminal指令 檢視\u0026gt;其他視窗\u0026gt;套件管理器主控台 下方會出現命令列 輸入dir會顯示目錄檔案及子目錄清單 輸入cd EFCoreExample移動到專案檔底下後再輸入dir確認是否到正確路徑 輸入dotnet tool install --global dotnet-ef在全域安裝EFCore CLI工具(如果已經安裝，會出現下圖訊息，即可忽略此步驟) 輸入dotnet ef migrations add CreateInitial初始化SQLite 輸入dotnet ef database update更新SQLite資料表 成功就會自動產生Migrations資料夾 編輯WeatherForecastController.cs類別檔 將EFCoreContext注入WeatherForecastController.cs 將預設的API註解 寫新的對外API // [HttpGet(\u0026#34;InsertAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; InsertAsync() { //新增一筆資料 var data = new Student() { Name = \u0026#34;BillHuang\u0026#34;, Age = 20 }; //加到Students這張table內 _context.Students.Add(data); //執行，並回傳成功數量 return Ok(await _context.SaveChangesAsync()); } 執行結果 F5執行後，依照下列步驟操作，並確認結果 參考 efcore影片介紹 余小章 @ 大內殿堂\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-efcore%E7%AF%84%E4%BE%8B/","summary":"目的 透過EFCore對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample.Models; namespace EFCoreExample.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.","title":"2022ITHelp dotnet6 EFCore範例"},{"content":"目的 說明Dapper基本語法\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite 編輯WeatherForecastController檔案 將預設的API註解 基本設定 /// \u0026lt;summary\u0026gt; /// 初始化SQLite /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static async Task InitSqliteAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //判斷是否有Student.sqlite檔案 if (!System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //新增一張表，就會建立.sqlite檔案 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await conn.ExecuteAsync(SQL.ToString()); } //Task不建議使用void，當不需要回傳值時會改用Task.CompletedTask說明已經完成，可以下一個步驟了。 await Task.CompletedTask; } public class Student { public int Id { get; set; } //Name預設值為Billhuang，與以前建構子的寫法一樣，如下方寫法 //public Student(){Name=\u0026#34;BillHuang\u0026#34;;} public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 寫新的對外API：ExcuteAsync /// \u0026lt;summary\u0026gt; /// ExecuteAsync可用於insert、delete、update /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;ExcuteAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; ExcuteAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;INSERT INTO Student (Name, Age) VALUES (@Name, @Age);\u0026#34;); DynamicParameters parameters = new(); parameters.Add(\u0026#34;Name\u0026#34;, \u0026#34;BillHuang\u0026#34;); parameters.Add(\u0026#34;Age\u0026#34;, 20); var Result = await conn.ExecuteAsync(SQL.ToString(), parameters); return Ok(Result); } 寫新的對外API：QueryAsync /// \u0026lt;summary\u0026gt; /// QueryAsync可用於select /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;QueryAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;select * from Student\u0026#34;); var Result = await conn.QueryAsync\u0026lt;Student\u0026gt;(SQL.ToString()); return Ok(Result); } 寫新的對外API：QueryFirstOrDefaultAsync 取得第一筆的方法有四種，個人都是使用QueryFirstOrDefault，並判斷是否為null，如下列範例。 指令 沒有值 有一個值 有多個值 QueryFirst exception V 取第一筆 QuerySingle exception V exception QueryFirstOrDefault null V 取第一筆 QuerySingleOrDefault null V exception /// \u0026lt;summary\u0026gt; /// 取得select第一筆 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;QueryFirstOrDefaultAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryFirstOrDefaultAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;select * from Student\u0026#34;); var Result = await conn.QueryFirstOrDefaultAsync\u0026lt;Student\u0026gt;(SQL.ToString()); if (Result is not null) { return Ok(Result); } return Ok(Result); } 交易機制 當有多張表需要異動時，為了確認資料的一致性，會需要透過交易機制做保護，只有全部成功或全部失敗。 /// \u0026lt;summary\u0026gt; /// 交易機制，簡單說就是全部成功才算成功，不然就全部取消。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;TransactionsAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; TransactionsAsync() { using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); //開啟連線，前面沒有這行是因為在在執行語法時(Execute、Query)會自動檢查是否連接資料庫 conn.Open(); //開始資料庫交易 var trans = conn.BeginTransaction(); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;INSERT INTO Student (Name, Age) VALUES (@Name, @Age);\u0026#34;); DynamicParameters parameters = new(); parameters.Add(\u0026#34;Name\u0026#34;, \u0026#34;BillHuang\u0026#34;); parameters.Add(\u0026#34;Age\u0026#34;, 20); //執行完並不會真的異動資料 await conn.ExecuteAsync(SQL.ToString(), parameters, trans); SQL.Clear(); SQL.Append(\u0026#34;select * from Student\u0026#34;); var Result = await conn.QueryFirstOrDefaultAsync\u0026lt;Student\u0026gt;(SQL.ToString(), trans); //當程式執行到Commit才是真的執行成功。 trans.Commit(); return Ok(); } 範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-dapper%E8%AA%9E%E6%B3%95%E8%AA%AA%E6%98%8E/","summary":"目的 說明Dapper基本語法\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite 編輯WeatherForecastController檔案 將預設的API註解 基本設定 /// \u0026lt;summary\u0026gt; /// 初始化SQLite /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static async Task InitSqliteAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //判斷是否有Student.sqlite檔案 if (!System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //新增一張表，就會建立.sqlite檔案 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await conn.ExecuteAsync(SQL.ToString()); } //Task不建議使用void，當不需要回傳值時會改用Task.","title":"2022ITHelp dotnet6 Dapper語法說明"},{"content":"目的 透過dapper對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite(微軟官方還是SQLite官方?黑暗執行緒前輩有做說明，我的選擇比較單純有微軟用微軟) 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API /// \u0026lt;summary\u0026gt; /// 檢查有沒有sqlite檔案，沒有就新增，並增加一筆資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;InsertAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; InsertAsync() { //連接sqlite資料庫 using var connection = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //當找不到sqlite檔案時，建立新表，新表創建後就會產生sqlite檔案了 if (System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //組語法，新建名為Student的表 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); //Id欄位設定數字型別為PKey，並且自動遞增 SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); //Name欄位設定為VARCHAR(32)不允許是null SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); //Age欄位設定為int SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await connection.ExecuteAsync(SQL.ToString()); //清除字串內的值 SQL.Clear(); } //組語法 SQL.Append(\u0026#34;INSERT INTO Student (Name, Age) VALUES (@Name, @Age);\u0026#34;); //建立SQL參數化要使用的變數 DynamicParameters parameters = new(); //參數1 parameters.Add(\u0026#34;Name\u0026#34;, \u0026#34;BillHuang\u0026#34;); //參數2 parameters.Add(\u0026#34;Age\u0026#34;, 20); //執行語法，insert一筆資料到Student var Result = await conn.ExecuteAsync(SQL.ToString(), parameters); //回傳執行成功的數量 return Ok(Result); } /// \u0026lt;summary\u0026gt; /// 取得Student所有資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;SelectAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; SelectAsync() { //連接sqlite資料庫 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //組語法 SQL.Append(\u0026#34;select * from Student\u0026#34;); //執行，並且將執行結果存為強型別 var Result = await conn.QueryAsync\u0026lt;Student\u0026gt;(SQL.ToString()); //回傳結果 return Ok(Result); } public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果\nInsert Select 參考 微軟官方還是SQLite官方\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-dapper%E7%AF%84%E4%BE%8B/","summary":"目的 透過dapper對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite(微軟官方還是SQLite官方?黑暗執行緒前輩有做說明，我的選擇比較單純有微軟用微軟) 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API /// \u0026lt;summary\u0026gt; /// 檢查有沒有sqlite檔案，沒有就新增，並增加一筆資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;InsertAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; InsertAsync() { //連接sqlite資料庫 using var connection = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //當找不到sqlite檔案時，建立新表，新表創建後就會產生sqlite檔案了 if (System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //組語法，新建名為Student的表 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); //Id欄位設定數字型別為PKey，並且自動遞增 SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); //Name欄位設定為VARCHAR(32)不允許是null SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); //Age欄位設定為int SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await connection.","title":"2022ITHelp dotnet6 Dapper範例"},{"content":"目的 使用epplus製作長條圖\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)] public ActionResult ImportExcel() { //建立excel所有操作的實例 using ExcelPackage excelPackage = new(); var ws = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;); Random Random = new Random(); //ws.Cells[上下(row),左右(col)] ws.Cells[1, 2].Value = \u0026#34;第一季\u0026#34;; ws.Cells[1, 3].Value = \u0026#34;第二季\u0026#34;; ws.Cells[1, 4].Value = \u0026#34;第三季\u0026#34;; ws.Cells[1, 5].Value = \u0026#34;第四季\u0026#34;; ws.Cells[2, 1].Value = \u0026#34;A組\u0026#34;; ws.Cells[3, 1].Value = \u0026#34;B組\u0026#34;; ws.Cells[4, 1].Value = \u0026#34;C組\u0026#34;; ws.Cells[5, 1].Value = \u0026#34;D組\u0026#34;; for (int i = 2; i \u0026lt;= 5; i++) { for (int j = 2; j \u0026lt;= 5; j++) { ws.Cells[i, j].Value = Random.Next(70, 150); } } //建立長條圖 var BarChart = ws.Drawings.AddBarChart(\u0026#34;BarChart\u0026#34;, eBarChartType.ColumnClustered); //長條圖名稱 BarChart.Title.Text = \u0026#34;年度季報表\u0026#34;; //長條圖的位置 BarChart.SetPosition(6, 0, 6, 0); //長條圖大小 BarChart.SetSize(400, 400); //第一個顏色長條圖BarChart.Series.Add(數據區間，x軸名稱區間)=\u0026gt;數據區間從(2,2)到(2,5)，X軸名稱(第一季、第二季、第三季、第四季) var Ateam = BarChart.Series.Add(ExcelCellBase.GetAddress(2, 2, 2, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); //第一條顏色的名稱(A組) Ateam.Header = ws.Cells[2, 1].Text; var Bteam = BarChart.Series.Add(ExcelCellBase.GetAddress(3, 2, 3, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); Bteam.Header = ws.Cells[3, 1].Text; var Cteam = BarChart.Series.Add(ExcelCellBase.GetAddress(4, 2, 4, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); Cteam.Header = ws.Cells[4, 1].Text; var Dteam = BarChart.Series.Add(ExcelCellBase.GetAddress(5, 2, 5, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); Dteam.Header = ws.Cells[5, 1].Text; //樣式使用1 BarChart.StyleManager.SetChartStyle(ePresetChartStyle.HistogramChartStyle1); //將檔案匯出 return File(excelPackage.GetAsByteArray(), \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;, \u0026#34;製作長條圖\u0026#34;); } 範例太長，只擷取部分 執行結果 範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-epplus%E5%9C%96%E8%A1%A8%E7%AF%84%E4%BE%8B/","summary":"目的 使用epplus製作長條圖\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)] public ActionResult ImportExcel() { //建立excel所有操作的實例 using ExcelPackage excelPackage = new(); var ws = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;); Random Random = new Random(); //ws.Cells[上下(row),左右(col)] ws.Cells[1, 2].Value = \u0026#34;第一季\u0026#34;; ws.Cells[1, 3].Value = \u0026#34;第二季\u0026#34;; ws.Cells[1, 4].Value = \u0026#34;第三季\u0026#34;; ws.Cells[1, 5].Value = \u0026#34;第四季\u0026#34;; ws.Cells[2, 1].","title":"2022ITHelp dotnet6 EPPlus圖表範例"},{"content":"目的 將資料匯出成excel\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)]\rpublic ActionResult ImportExcel() {\r//建立excel所有操作的實例\rusing ExcelPackage excelPackage = new();\r//properties為excel的屬性，開啟excel後要特別去查看屬性才能看到的資訊\rexcelPackage.Workbook.Properties.Author = \u0026#34;Bill Huang\u0026#34;;\rexcelPackage.Workbook.Properties.Title = \u0026#34;範例檔案\u0026#34;;\rexcelPackage.Workbook.Properties.Created = DateTime.Now;\r//建立第一頁工作表(下方所顯示的頁簽)\rExcelWorksheet worksheet = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;);\rint i = 1;\rforeach (var c in Summaries) {\r//選擇指定欄位將資料放入\rworksheet.Cells[i,1].Value = c;\ri++;\r}\r//將檔案匯出\rreturn File(excelPackage.GetAsByteArray(), \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;, \u0026#34;excel檔案預設名稱\u0026#34;);\r} 執行結果 F5執行後，依照下列步驟操作，並將檔案下載下來 參考 伊果的沒人看筆記本\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-epplus%E7%AF%84%E4%BE%8B/","summary":"目的 將資料匯出成excel\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)]\rpublic ActionResult ImportExcel() {\r//建立excel所有操作的實例\rusing ExcelPackage excelPackage = new();\r//properties為excel的屬性，開啟excel後要特別去查看屬性才能看到的資訊\rexcelPackage.Workbook.Properties.Author = \u0026#34;Bill Huang\u0026#34;;\rexcelPackage.Workbook.Properties.Title = \u0026#34;範例檔案\u0026#34;;\rexcelPackage.Workbook.Properties.Created = DateTime.Now;\r//建立第一頁工作表(下方所顯示的頁簽)\rExcelWorksheet worksheet = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;);\rint i = 1;\rforeach (var c in Summaries) {\r//選擇指定欄位將資料放入\rworksheet.","title":"2022ITHelp dotnet6 EPPlus範例"},{"content":"目的 將預設回傳的Camel-Case(temperatureCelsius)改為Pascal Case(TemperatureCelsius)\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar options = new JsonSerializerOptions {\rPropertyNamingPolicy = null,\r};\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18,\u0026#34;\u0026#34;TemperatureCelsius\u0026#34;\u0026#34;:52}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString,options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\rpublic int TemperatureCelsius { get; set; }\r} Program寫入程式 builder.Services.AddControllers()\r.AddJsonOptions(options =\u0026gt; {\r//預設為小駝峰命名，將此參數改為null即可使用大駝峰命名\roptions.JsonSerializerOptions.PropertyNamingPolicy = null;\r}); 執行結果 參考 大駝峰命名\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-%E6%9B%B4%E6%94%B9%E5%9B%9E%E5%82%B3json%E6%99%82%E7%82%BA%E5%A4%A7%E9%A7%9D%E5%B3%B0%E5%91%BD%E5%90%8D/","summary":"目的 將預設回傳的Camel-Case(temperatureCelsius)改為Pascal Case(TemperatureCelsius)\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar options = new JsonSerializerOptions {\rPropertyNamingPolicy = null,\r};\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18,\u0026#34;\u0026#34;TemperatureCelsius\u0026#34;\u0026#34;:52}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString,options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\rpublic int TemperatureCelsius { get; set; }\r} Program寫入程式 builder.","title":"2022ITHelp dotnet6 更改回傳Json時為大駝峰命名"},{"content":"目的 序列化時不自動將非ASCII轉為Unicode\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using [HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar options = new JsonSerializerOptions {\r//美化輸出，會有空白字元\rWriteIndented = true,\r//將所有語言都不進行轉換\rEncoder = JavaScriptEncoder.Create(UnicodeRanges.All)\r};\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18,\r};\rvar Result = JsonSerializer.Serialize(Test, options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 中文就不會是unicode了 參考 How to serialize and deserialize\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-%E8%A7%A3%E6%B1%BAsystem.text.json%E5%BA%8F%E5%88%97%E5%8C%96%E5%BE%8C%E6%9C%83%E5%B0%87%E6%89%80%E6%9C%89%E9%9D%9Eascii%E8%BD%89%E7%82%BAunicode/","summary":"目的 序列化時不自動將非ASCII轉為Unicode\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using [HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar options = new JsonSerializerOptions {\r//美化輸出，會有空白字元\rWriteIndented = true,\r//將所有語言都不進行轉換\rEncoder = JavaScriptEncoder.Create(UnicodeRanges.All)\r};\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18,\r};\rvar Result = JsonSerializer.Serialize(Test, options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 中文就不會是unicode了 參考 How to serialize and deserialize","title":"2022ITHelp dotnet6 解決System.Text.Json序列化後會將所有非ASCII轉為Unicode"},{"content":"目的 不使用Newtonsoft.Json，改採.net6內建的System.Text.Json System.Text.Json更著重在效能與安全性，大多數人應該都跟我一樣只會使用基本的序列化及反序列化。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18\r};\rvar Result = JsonSerializer.Serialize(Test);\rreturn Ok(Result);\r}\r/// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 點選Try it out 點選Execute 查看執行結果1(序列化) 查看執行結果2(反序列化) 延伸問題 在不做任何設定的情況下，內建的序列化會有些微差異\n序列化預設會將所有非ASCII轉為Unicode代碼，例如：中文名=\u0026gt;\\u4E2D\\u6587\\u540D 使用ActionResult中的JsonResult回傳時會將開頭改為小寫\n反序列化後輸出為小寫的key(如結果2)，原先的TestClass是大寫的Name與Age 兩個問題都會在另一個章節補充說明\n參考 Compare Newtonsoft.Json to System.Text.Json, and migrate to System.Text.Json\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-text.json%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%84%E4%BE%8B/","summary":"目的 不使用Newtonsoft.Json，改採.net6內建的System.Text.Json System.Text.Json更著重在效能與安全性，大多數人應該都跟我一樣只會使用基本的序列化及反序列化。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18\r};\rvar Result = JsonSerializer.Serialize(Test);\rreturn Ok(Result);\r}\r/// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 點選Try it out 點選Execute 查看執行結果1(序列化) 查看執行結果2(反序列化) 延伸問題 在不做任何設定的情況下，內建的序列化會有些微差異","title":"2022ITHelp dotnet6 Text.Json範例"},{"content":"目的 在swagger內使用jwt token測試API\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 NuGet加入套件 透過NuGet安裝\nJWT Microsoft.AspNetCore.Authentication.JwtBearer Microsoft.IdentityModel.Tokens System.IdentityModel.Tokens.Jwt 新增Helpers資料夾並在裡面新增JwtHelpers.cs類別檔案 jwt範例使用保哥範例來做修改，目的只是為了取得jwt token\npublic class JwtHelper { private readonly JwtSettingsOptions _settings; public JwtHelper(IOptionsMonitor\u0026lt;JwtSettingsOptions\u0026gt; settings) { //注入appsetting的json _settings = settings.CurrentValue; } public string GenerateToken(string userName, int expireMinutes = 120) { //發行人 var issuer = _settings.Issuer; //加密的key，拿來比對jwt-token沒有 var signKey = _settings.SignKey; 建立JWT-Token var token = JwtBuilder.Create() //所採用的雜湊演算法 .WithAlgorithm(new HMACSHA256Algorithm()) // symmetric //加密key .WithSecret(signKey) //角色 .AddClaim(\u0026#34;roles\u0026#34;, \u0026#34;admin\u0026#34;) //JWT ID .AddClaim(\u0026#34;jti\u0026#34;, Guid.NewGuid().ToString()) //發行人 .AddClaim(\u0026#34;iss\u0026#34;, issuer) //使用對象名稱 .AddClaim(\u0026#34;sub\u0026#34;, userName) // User.Identity.Name //過期時間 .AddClaim(\u0026#34;exp\u0026#34;, DateTimeOffset.UtcNow.AddMinutes(expireMinutes).ToUnixTimeSeconds()) //此時間以前是不可以使用 .AddClaim(\u0026#34;nbf\u0026#34;, DateTimeOffset.UtcNow.ToUnixTimeSeconds()) //發行時間 .AddClaim(\u0026#34;iat\u0026#34;, DateTimeOffset.UtcNow.ToUnixTimeSeconds()) //使用者全名 .AddClaim(ClaimTypes.Name, userName) //進行編碼 .Encode(); return token; } } //將appsetting轉為強行別所使用 public class JwtSettingsOptions { public string Issuer { get; set; } = \u0026#34;\u0026#34;; public string SignKey { get; set; } = \u0026#34;\u0026#34;; } 因篇幅過長，只擷取JwtHelpers.cs部分內容，記得要using下列命名空間\nusing JWT.Algorithms; using JWT.Builder; using Microsoft.Extensions.Options; using System.Security.Claims; 新增Filters資料夾並在裡面新增AuthorizeCheckOperationFilter.cs類別檔案 因為在使用swagger做認證測試時，會遇到一個很惱人的問題，就是當我的某些api並不需要做認證，卻還是會在畫面上顯示鎖頭\n第一支並沒有attribute，無須認證 第二支為AllowAnonymous，無須認證 第三支為Authorize，需要認證 public class AuthorizeCheckOperationFilter : IOperationFilter { private readonly EndpointDataSource _endpointDataSource; public AuthorizeCheckOperationFilter(EndpointDataSource endpointDataSource) { _endpointDataSource = endpointDataSource; } public void Apply(OpenApiOperation operation, OperationFilterContext context) { 取得所有controller內的action var Descriptor = _endpointDataSource.Endpoints.FirstOrDefault(x =\u0026gt; x.Metadata.GetMetadata\u0026lt;ControllerActionDescriptor\u0026gt;() == context.ApiDescription.ActionDescriptor); //取得包含Authorize的Attribute var Authorize = Descriptor.Metadata.GetMetadata\u0026lt;AuthorizeAttribute\u0026gt;() != null; //取得包含AllowAnonymous的Attribute var AllowAnonymous = Descriptor.Metadata.GetMetadata\u0026lt;AllowAnonymousAttribute\u0026gt;() != null; //如果不需要鎖頭則return回去 if (!Authorize || AllowAnonymous) return; //需要鎖頭則在swagger-UI中定義出來 operation.Security = new List\u0026lt;OpenApiSecurityRequirement\u0026gt; { new() { [ new OpenApiSecurityScheme {Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} } ] = new List\u0026lt;string\u0026gt;() } }; } } 編輯WeatherForecastController檔案 注入JwtHelper 第一支為預設沒有attribute的方法 第二支為登入方法，attribute是AllowAnonymous，任何人都可以使用 第三支為登入後才可以取得的資料，attribute是Authorize(Roles = \u0026ldquo;admin\u0026rdquo;)，role需要是admin才可以使用 [HttpGet(\u0026#34;Login\u0026#34;), AllowAnonymous] public ActionResult\u0026lt;string\u0026gt; Login(string username , string password) { var token = _jwtHelpers.GenerateToken(username); return Ok(token); } [HttpGet(\u0026#34;username\u0026#34;), Authorize(Roles = \u0026#34;admin\u0026#34;)] public ActionResult\u0026lt;string\u0026gt; Username() { return Ok(User.Identity?.Name); } 再次編輯Program.cs檔案 分兩個區塊說明\nJWT設定 //清除預設映射 JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear(); //註冊JwtHelper builder.Services.AddSingleton\u0026lt;JwtHelper\u0026gt;(); //使用選項模式註冊 builder.Services.Configure\u0026lt;JwtSettingsOptions\u0026gt;( builder.Configuration.GetSection(\u0026#34;JwtSettings\u0026#34;)); //設定認證方式 builder.Services //使用bearer token方式認證並且token用jwt格式 .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.TokenValidationParameters = new TokenValidationParameters { // 可以讓[Authorize]判斷角色 RoleClaimType = \u0026#34;roles\u0026#34;, // 預設會認證發行人 ValidateIssuer = true, ValidIssuer = builder.Configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), // 不認證使用者 ValidateAudience = false, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已 ValidateIssuerSigningKey = true, // 簽章所使用的key IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:SignKey\u0026#34;))) }; }); 2. Swagger-UI調整\n//說明api如何受到保護 options.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { Name = \u0026#34;Authorization\u0026#34;, //選擇類型，type選擇http時，透過swagger畫面做認證時可以省略Bearer前綴詞(如下圖) Type = SecuritySchemeType.Http, //採用Bearer token Scheme = \u0026#34;Bearer\u0026#34;, //bearer格式使用jwt BearerFormat = \u0026#34;JWT\u0026#34;, //認證放在http request的header上 In = ParameterLocation.Header, //描述 Description = \u0026#34;JWT驗證描述\u0026#34; }); //製作額外的過濾器，過濾Authorize、AllowAnonymous，甚至是沒有打attribute options.OperationFilter\u0026lt;AuthorizeCheckOperationFilter\u0026gt;(); Type使用SecuritySchemeType.Http，不用打Bearer Type使用SecuritySchemeType.ApiKey，需要打Bearer與空白以及文字描述會包含Name、In、Description 在下方別忘了使用認證的中介層 執行結果 在登入的api輸入帳號密碼 會回傳一組jwt token 點擊認證按鈕，將token輸入 使用有鎖頭的API 最後可以正確取得回傳值就是成功了 如果不輸入token直接使用有鎖頭的API，就會跳出401錯誤 參考 保哥 伊果的沒人看筆記本 實作Filter JWT規範\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-swagger%E6%8E%88%E6%AC%8A/","summary":"目的 在swagger內使用jwt token測試API\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 NuGet加入套件 透過NuGet安裝\nJWT Microsoft.AspNetCore.Authentication.JwtBearer Microsoft.IdentityModel.Tokens System.IdentityModel.Tokens.Jwt 新增Helpers資料夾並在裡面新增JwtHelpers.cs類別檔案 jwt範例使用保哥範例來做修改，目的只是為了取得jwt token\npublic class JwtHelper { private readonly JwtSettingsOptions _settings; public JwtHelper(IOptionsMonitor\u0026lt;JwtSettingsOptions\u0026gt; settings) { //注入appsetting的json _settings = settings.CurrentValue; } public string GenerateToken(string userName, int expireMinutes = 120) { //發行人 var issuer = _settings.","title":"2022ITHelp dotnet6 swagger授權"},{"content":"目的 每次要使用swaggerUI時候範例總是各式各樣，千奇百怪，下列範例是使用官方預設的Swashbuckle套件來教學。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解 program檔案與.net5以前不一樣，保哥的部落格有比較詳細的說明\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 編輯WeatherForecastController檔案 這裡有個重點，如果要增加下一個action時候，預設的範例檔案，需要調整route的設定，才能讀取到，不然會跳錯誤訊息\n加入前 加入後 加入第二個方法 執行結果 就可以成功讀取到兩個方法了 參考 微軟官方\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-swagger%E7%AF%84%E4%BE%8B/","summary":"目的 每次要使用swaggerUI時候範例總是各式各樣，千奇百怪，下列範例是使用官方預設的Swashbuckle套件來教學。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解 program檔案與.net5以前不一樣，保哥的部落格有比較詳細的說明\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 編輯WeatherForecastController檔案 這裡有個重點，如果要增加下一個action時候，預設的範例檔案，需要調整route的設定，才能讀取到，不然會跳錯誤訊息\n加入前 加入後 加入第二個方法 執行結果 就可以成功讀取到兩個方法了 參考 微軟官方\n範例檔 GitHub","title":"2022ITHelp dotnet6 swagger範例"},{"content":"目的 使用telegram做聊天機器人\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Telegram.Bot 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(\u0026#34;Test\u0026#34;)]\rpublic async Task\u0026lt;string\u0026gt; Test() {\rvar botClient = new TelegramBotClient(\u0026#34;前置作業給的機器人ID\u0026#34;);\r//取得機器人基本資訊\rvar me = await botClient.GetMeAsync();\r//發送訊息到指定頻道\rMessage message = await botClient.SendTextMessageAsync(\rchatId: \u0026#34;前置作業給的頻道ID\u0026#34;,\rtext: \u0026#34;Trying *all the parameters* of `sendMessage` method\u0026#34;);\r//回傳取得的機器人基本資訊\rreturn $\u0026#34;Hello, World! I am user {me.Id} and my name is {me.FirstName}.\u0026#34;;\r} 執行結果 F5執行後，依照下列步驟操作，並確認結果 就可以看到telegram的機器人有發送一個訊息 參考 官方文件 holey\u0026rsquo;s Blog\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-telegram.bot%E7%AF%84%E4%BE%8B/","summary":"目的 使用telegram做聊天機器人\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Telegram.Bot 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(\u0026#34;Test\u0026#34;)]\rpublic async Task\u0026lt;string\u0026gt; Test() {\rvar botClient = new TelegramBotClient(\u0026#34;前置作業給的機器人ID\u0026#34;);\r//取得機器人基本資訊\rvar me = await botClient.GetMeAsync();\r//發送訊息到指定頻道\rMessage message = await botClient.SendTextMessageAsync(\rchatId: \u0026#34;前置作業給的頻道ID\u0026#34;,\rtext: \u0026#34;Trying *all the parameters* of `sendMessage` method\u0026#34;);\r//回傳取得的機器人基本資訊\rreturn $\u0026#34;Hello, World! I am user {me.Id} and my name is {me.FirstName}.\u0026#34;;\r} 執行結果 F5執行後，依照下列步驟操作，並確認結果 就可以看到telegram的機器人有發送一個訊息 參考 官方文件 holey\u0026rsquo;s Blog","title":"2022ITHelp dotnet6 Telegram.Bot範例"},{"content":"目的 在使用telegram機器人時，需要先在telegram新增要使用的機器人。\n搜尋 搜尋@botfather 開始 點擊start 輸入/newbot指令 輸入/newbot指令後，對話欄會請你輸入你的名稱。 設定聊天機器人的顯示名稱 這邊所輸入的名稱，並沒有限制要Bot或_bot當結尾。 設定機器人帳號 其他人可以透過查詢帳號找到我們所建立的機器人。\n當要輸入機器人帳號時，會限制要Bot或_bot結尾，需要特別注意。\n取得token 如馬賽克處，是使用機器人時所要提供給api的token。 參考 官方文件\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-telegram.bot%E5%89%8D%E7%BD%AE%E4%BD%9C%E6%A5%AD/","summary":"目的 在使用telegram機器人時，需要先在telegram新增要使用的機器人。\n搜尋 搜尋@botfather 開始 點擊start 輸入/newbot指令 輸入/newbot指令後，對話欄會請你輸入你的名稱。 設定聊天機器人的顯示名稱 這邊所輸入的名稱，並沒有限制要Bot或_bot當結尾。 設定機器人帳號 其他人可以透過查詢帳號找到我們所建立的機器人。\n當要輸入機器人帳號時，會限制要Bot或_bot結尾，需要特別注意。\n取得token 如馬賽克處，是使用機器人時所要提供給api的token。 參考 官方文件","title":"2022ITHelp dotnet6 Telegram.Bot前置作業"},{"content":"目的 快速且簡單的製造假資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝\nBogus 編輯WeatherForecastController檔案 將預設的API註解 //除了using Bogus外，需注意需要using static Bogus.DataSets.Name，為了取得Gender using static Bogus.DataSets.Name; [HttpGet(\u0026#34;Test\u0026#34;)] public List\u0026lt;User\u0026gt; Test() { //可限制隨機值為定值 //Randomizer.Seed = new Random(8675307); //建立一個假的貨品陣列 var fruit = new[] { \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;kiwi\u0026#34; }; //預設訂單編號為0 var orderIds = 0; //預設取得英文資料 var testOrders = new Faker\u0026lt;Order\u0026gt;() //強制所有屬性都要有規則存在，預設為false .StrictMode(true) //OrderId is deterministic .RuleFor(o =\u0026gt; o.OrderId, f =\u0026gt; orderIds++) //從自訂陣列隨機取值 .RuleFor(o =\u0026gt; o.Item, f =\u0026gt; f.PickRandom(fruit)) //從1-10隨機取值 .RuleFor(o =\u0026gt; o.Quantity, f =\u0026gt; f.Random.Number(1, 10)) //從1-100隨機取值，並有20%機會為NULL .RuleFor(o =\u0026gt; o.LotNumber, f =\u0026gt; f.Random.Int(0, 100).OrNull(f, .2f)); //預設使用者編號為0 var userIds = 0; var testUsers = new Faker\u0026lt;User\u0026gt;() //使用需要初始化的類別 .CustomInstantiator(f =\u0026gt; new User(userIds++, f.Random.Replace(\u0026#34;(##)###-####\u0026#34;))) //從列舉中隨機取值(Gender為Bogus內建) .RuleFor(u =\u0026gt; u.Gender, f =\u0026gt; f.PickRandom\u0026lt;Gender\u0026gt;()) //使用內建的生成器 .RuleFor(u =\u0026gt; u.FirstName, (f, u) =\u0026gt; f.Name.FirstName(u.Gender)) .RuleFor(u =\u0026gt; u.LastName, (f, u) =\u0026gt; f.Name.LastName(u.Gender)) .RuleFor(u =\u0026gt; u.Avatar, f =\u0026gt; f.Internet.Avatar()) .RuleFor(u =\u0026gt; u.UserName, (f, u) =\u0026gt; f.Internet.UserName(u.FirstName, u.LastName)) .RuleFor(u =\u0026gt; u.Email, (f, u) =\u0026gt; f.Internet.Email(u.FirstName, u.LastName)) .RuleFor(u =\u0026gt; u.SomethingUnique, f =\u0026gt; $\u0026#34;Value {f.UniqueIndex}\u0026#34;) //可使用非Bogus的方法，建立一個新的GUID .RuleFor(u =\u0026gt; u.CartId, f =\u0026gt; Guid.NewGuid()) //可使用複合屬性 .RuleFor(u =\u0026gt; u.FullName, (f, u) =\u0026gt; $\u0026#34;{u.FirstName} {u.LastName}\u0026#34;) //複雜的集合也可以使用，並重複產生5個訂單的陣列 .RuleFor(u =\u0026gt; u.Orders, f =\u0026gt; testOrders.Generate(5).ToList()) //最後結束後可以執行特定動作 .FinishWith((f, u) =\u0026gt; { Console.WriteLine(\u0026#34;User Created! Id={0}\u0026#34;, u.Id); }); //產生3個使用者 var user = testUsers.Generate(3); return user; } public class User { public User(int v1, string v2) { Id = v1; SSN = v2; } public int Id { get; set; } public Gender Gender { get; set; } public string SSN { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Avatar { get; set; } public string UserName { get; set; } public string Email { get; set; } public string SomethingUnique { get; set; } public Guid CartId { get; set; } public string FullName { get; set; } public List\u0026lt;Order\u0026gt; Orders { get; set; } } public class Order { public int OrderId { get; set; } public string Item { get; set; } public int Quantity { get; set; } public int? LotNumber { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果 參考 kinanson的技術回憶 參考\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-bogus%E7%AF%84%E4%BE%8B/","summary":"目的 快速且簡單的製造假資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝\nBogus 編輯WeatherForecastController檔案 將預設的API註解 //除了using Bogus外，需注意需要using static Bogus.DataSets.Name，為了取得Gender using static Bogus.DataSets.Name; [HttpGet(\u0026#34;Test\u0026#34;)] public List\u0026lt;User\u0026gt; Test() { //可限制隨機值為定值 //Randomizer.Seed = new Random(8675307); //建立一個假的貨品陣列 var fruit = new[] { \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;kiwi\u0026#34; }; //預設訂單編號為0 var orderIds = 0; //預設取得英文資料 var testOrders = new Faker\u0026lt;Order\u0026gt;() //強制所有屬性都要有規則存在，預設為false .StrictMode(true) //OrderId is deterministic .RuleFor(o =\u0026gt; o.OrderId, f =\u0026gt; orderIds++) //從自訂陣列隨機取值 .RuleFor(o =\u0026gt; o.Item, f =\u0026gt; f.","title":"2022ITHelp dotnet6 Bogus範例"},{"content":"目的 批次註冊\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 新增類別檔 新增之後需要來描述要批次注入的規則\n加入前 加入後 並且繼承autofac的類別Module 編輯Program.cs檔案 //初始化並建立一個實例 builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory()); //註冊autofac這個容器 builder.Host.ConfigureContainer\u0026lt;ContainerBuilder\u0026gt;(builder =\u0026gt; builder.RegisterModule(new AutofacModuleRegister())); 有繼承autofac的類別Module 新增資料夾 新增下圖兩個資料夾 新增類別檔 此次的目的是要可以進行批次注入，所以檔名結尾都需要包含Service，做批次注入時可以辨識\n在Services資料夾底下加入類別檔案，名稱為TestService 在Interface資料夾底下加入介面檔案，名稱為ITest ITest.cs寫入程式 namespace AutoFacExample.Services.Interface { public interface ITest { public string GetName(string id); } } TestService.cs寫入程式 繼承介面後寫上與介面相同的方法 using AutoFacExample.Services.Interface; namespace AutoFacExample.Services { public class TestService : ITest { public string GetName(string id) { return $\u0026#34;{id}:Bill\u0026#34;; } } } AutofacModuleRegister執行批次註冊 protected override void Load(ContainerBuilder builder) { //RegisterAssemblyTypes =\u0026gt; 註冊所有集合 //Where(t =\u0026gt; t.Name.EndsWith(\u0026#34;Service\u0026#34;)) =\u0026gt; 找出所有Service結尾的檔案 //AsImplementedInterfaces =\u0026gt; 找到Service後註冊到其所繼承的介面 builder.RegisterAssemblyTypes(typeof(Program).Assembly) .Where(t =\u0026gt; t.Name.EndsWith(\u0026#34;Service\u0026#34;)) .AsImplementedInterfaces(); } 新增測試用controller TestController.cs寫入程式 using AutoFacExample.Services.Interface; using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; namespace AutoFacExample.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class TestController : ControllerBase { //為隱私修飾詞並且唯讀 private readonly ITest _test; //在建構子時注入需要使用的服務 public TestController(ITest test) { _test = test; } [HttpGet(\u0026#34;GetName\u0026#34;)] public string Get(string id) { //使用注入的服務 return _test.GetName(id); } } } 注入的服務都是使用介面，目的是之後方便抽換，才可以進行測試 命名原則都會加一個底線代表全域變數 執行結果 最終確認程式是可執行，就沒有問題了。 參考 .net6註冊autofac說明文件 參考文件 參考文件 參考文件\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-autofac%E7%AF%84%E4%BE%8B/","summary":"目的 批次註冊\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 新增類別檔 新增之後需要來描述要批次注入的規則\n加入前 加入後 並且繼承autofac的類別Module 編輯Program.cs檔案 //初始化並建立一個實例 builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory()); //註冊autofac這個容器 builder.Host.ConfigureContainer\u0026lt;ContainerBuilder\u0026gt;(builder =\u0026gt; builder.RegisterModule(new AutofacModuleRegister())); 有繼承autofac的類別Module 新增資料夾 新增下圖兩個資料夾 新增類別檔 此次的目的是要可以進行批次注入，所以檔名結尾都需要包含Service，做批次注入時可以辨識\n在Services資料夾底下加入類別檔案，名稱為TestService 在Interface資料夾底下加入介面檔案，名稱為ITest ITest.cs寫入程式 namespace AutoFacExample.Services.Interface { public interface ITest { public string GetName(string id); } } TestService.cs寫入程式 繼承介面後寫上與介面相同的方法 using AutoFacExample.Services.Interface; namespace AutoFacExample.Services { public class TestService : ITest { public string GetName(string id) { return $\u0026#34;{id}:Bill\u0026#34;; } } } AutofacModuleRegister執行批次註冊 protected override void Load(ContainerBuilder builder) { //RegisterAssemblyTypes =\u0026gt; 註冊所有集合 //Where(t =\u0026gt; t.","title":"2022ITHelp dotnet6 Autofac範例"},{"content":"目的 快速測試不同寫法的效能差異。\n建立新專案 選擇主控台應用程式專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 下載BenchmarkDotNet套件與automapper套件，automapper為這次要測試效能的套件 Program寫入程式 此次要測試的項目為三種類別轉換的效能差異\nusing AutoMapper; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; //指定要測試的class var summary = BenchmarkRunner.Run\u0026lt;BenchmarkSampleAuto\u0026gt;(); //加入記憶體使用量測試 [MemoryDiagnoser] public class BenchmarkSampleAuto { private readonly List\u0026lt;DbModel\u0026gt; _data = new List\u0026lt;DbModel\u0026gt;(); private readonly IMapper _mapper; public BenchmarkSampleAuto() { //automapper設定 var config = new MapperConfiguration(cfg =\u0026gt; { cfg.CreateMap\u0026lt;DbModel, ViewModel\u0026gt;(); }); _mapper = new Mapper(config); //準備一份List資料 PrepareTestObjects(); } private void PrepareTestObjects() { _data.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill\u0026#34;, Age = 18, CreatedDate = DateTime.Now }); _data.Add(new DbModel() { Id = 1, Name = \u0026#34;CI-YU\u0026#34;, Age = 20, CreatedDate = DateTime.Now }); _data.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill Huang\u0026#34;, Age = 22, CreatedDate = DateTime.Now }); } //待測方法需要加上Benchmark屬性 [Benchmark] public List\u0026lt;ViewModel\u0026gt; first() { return _mapper.Map\u0026lt;List\u0026lt;ViewModel\u0026gt;\u0026gt;(_data); } //待測方法需要加上Benchmark屬性 [Benchmark] public List\u0026lt;ViewModel\u0026gt; second() { var listModel = new List\u0026lt;ViewModel\u0026gt;(); foreach (var c in _data) { listModel.Add(new ViewModel() { Id = c.Id, Name = c.Name, Age = c.Age }); } return listModel; } //待測方法需要加上Benchmark屬性 [Benchmark] public List\u0026lt;ViewModel\u0026gt; third() { var listModel = new List\u0026lt;ViewModel\u0026gt;(); listModel = _data.Select(c =\u0026gt; new ViewModel() { Id = c.Id, Name = c.Name, Age = c.Age }).ToList(); return listModel; } } public class DbModel { public int Id { get; set; } public string? Name { get; set; } public int Age { get; set; } public DateTime CreatedDate { get; set; } } public class ViewModel { public ViewModel() { Name = string.Empty; } public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } 執行測試 執行測試前需要將組態改為Release才可以進行測試\n執行結果 最後的執行結果發現第二種方法的效能是最好的，通常最主要是看mean及allocated兩個參數\nMean 平均時間 Allocated 記憶體使用量 補充 在專案資料夾bin\\Release\\net6.0\\BenchmarkDotNet.Artifacts\\results底下會有詳細的報告，檔案格式有csv,html,md\n參考資料 參考 伊果的沒人看筆記本\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-benchmarkdotnet%E7%AF%84%E4%BE%8B/","summary":"目的 快速測試不同寫法的效能差異。\n建立新專案 選擇主控台應用程式專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 下載BenchmarkDotNet套件與automapper套件，automapper為這次要測試效能的套件 Program寫入程式 此次要測試的項目為三種類別轉換的效能差異\nusing AutoMapper; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; //指定要測試的class var summary = BenchmarkRunner.Run\u0026lt;BenchmarkSampleAuto\u0026gt;(); //加入記憶體使用量測試 [MemoryDiagnoser] public class BenchmarkSampleAuto { private readonly List\u0026lt;DbModel\u0026gt; _data = new List\u0026lt;DbModel\u0026gt;(); private readonly IMapper _mapper; public BenchmarkSampleAuto() { //automapper設定 var config = new MapperConfiguration(cfg =\u0026gt; { cfg.CreateMap\u0026lt;DbModel, ViewModel\u0026gt;(); }); _mapper = new Mapper(config); //準備一份List資料 PrepareTestObjects(); } private void PrepareTestObjects() { _data.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill\u0026#34;, Age = 18, CreatedDate = DateTime.","title":"2022ITHelp dotnet6 BenchmarkDotNet範例"},{"content":"目的 快速對應，不需要寫linq來將資料庫端的model對應到view要用的model\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝AutoMapper.Extensions.Microsoft.DependencyInjection 編輯Program.cs檔案 註冊AutoMapper\n//找到所有繼承profile builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies()); 新增Mappings資料夾與Models資料夾 在Models資料夾內加入DbModel資料夾與ViewModel資料夾 加入類別檔 在兩個資料夾內加入同名稱的類別檔案 DbModel.cs寫入程式碼 public int Id { get; set; } public string? Name { get; set; } public int Age { get; set; } public DateTime CreatedDate { get; set; } 可能會有些人問?是什麼，這是因為建立.net6專案預設會開啟判斷值可能為null的警告訊息，可以加上?代表允許此屬性為null，會建議在建構子時提供預設值，來避免嘗試對null值做處理的exception。\nViewModel.cs寫入程式 public ViewModel() { Name = string.Empty; } public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } 在建構子提供預設值後，來避免對null做處理。\n加入類別檔 在Mappings資料夾內加入名稱為ExampleMapping的類別檔 寫入程式 在新增的ExampleMapping.cs檔案內寫入程式碼 using AutoMapper; using AutoMapperExample.Models.DbModel; using AutoMapperExample.Models.ViewModel; namespace AutoMapperExample.Mappings { //需要繼承AutoMapper的Profile public class ExampleMapping : Profile { public ExampleMapping() { //來源與目標=\u0026gt;白話文是我要將DbModel對應到ViewModel CreateMap\u0026lt;DbModel, ViewModel\u0026gt;(); } } } 加入檔案 在Controllers加入一個空白的API控制器，並命名為ExampleController.cs 寫入程式 using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; using AutoMapperExample.Models.DbModel; using AutoMapperExample.Models.ViewModel; using AutoMapper; namespace AutoMapperExample.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class ExampleController : ControllerBase { private readonly IMapper _mapper; public ExampleController(IMapper mapper) { _mapper = mapper; } [HttpGet(\u0026#34;Index\u0026#34;)] public IEnumerable\u0026lt;ViewModel\u0026gt; Index() { var DbModel = new List\u0026lt;DbModel\u0026gt;(); //新增DbModel的List模擬從資料庫來的資料 DbModel.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill\u0026#34;, Age = 18, CreatedDate = DateTime.Now }); DbModel.Add(new DbModel() { Id = 1, Name = \u0026#34;CI-YU\u0026#34;, Age = 20, CreatedDate = DateTime.Now }); DbModel.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill Huang\u0026#34;, Age = 22, CreatedDate = DateTime.Now }); //將DbModel資料自動與ViewModel做對應(相同名稱的屬性) var map = _mapper.Map\u0026lt;IEnumerable\u0026lt;ViewModel\u0026gt;\u0026gt;(DbModel); return map; } } } 執行結果 可以自動對應到結果了。 範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-automapper%E7%AF%84%E4%BE%8B/","summary":"目的 快速對應，不需要寫linq來將資料庫端的model對應到view要用的model\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝AutoMapper.Extensions.Microsoft.DependencyInjection 編輯Program.cs檔案 註冊AutoMapper\n//找到所有繼承profile builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies()); 新增Mappings資料夾與Models資料夾 在Models資料夾內加入DbModel資料夾與ViewModel資料夾 加入類別檔 在兩個資料夾內加入同名稱的類別檔案 DbModel.cs寫入程式碼 public int Id { get; set; } public string? Name { get; set; } public int Age { get; set; } public DateTime CreatedDate { get; set; } 可能會有些人問?是什麼，這是因為建立.net6專案預設會開啟判斷值可能為null的警告訊息，可以加上?代表允許此屬性為null，會建議在建構子時提供預設值，來避免嘗試對null值做處理的exception。\nViewModel.cs寫入程式 public ViewModel() { Name = string.Empty; } public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } 在建構子提供預設值後，來避免對null做處理。","title":"2022ITHelp dotnet6 Automapper範例"},{"content":"目的 使用gmail寄信\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Google.Apis.Auth(使用google信箱時需要做oauth驗證才可以使用) MailKit(寄信) 編輯WeatherForecastController檔案 將預設的API註解 [HttpGet(\u0026#34;SendEmail\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get() { #region OAuth驗證 const string GMailAccount = \u0026#34;前置作業文章打上去的測試帳號\u0026#34;; var clientSecrets = new ClientSecrets { ClientId = \u0026#34;前置作業文章最後給的用戶ID\u0026#34;, ClientSecret = \u0026#34;前置作業文章最後給的用戶端密碼\u0026#34; }; var codeFlow = new GoogleAuthorizationCodeFlow(new GoogleAuthorizationCodeFlow.Initializer { DataStore = new FileDataStore(\u0026#34;CredentialCacheFolder\u0026#34;, false), Scopes = new[] { \u0026#34;https://mail.google.com/\u0026#34; }, ClientSecrets = clientSecrets }); var codeReceiver = new LocalServerCodeReceiver(); var authCode = new AuthorizationCodeInstalledApp(codeFlow, codeReceiver); var credential = await authCode.AuthorizeAsync(GMailAccount, CancellationToken.None); if (credential.Token.IsExpired(SystemClock.Default)) await credential.RefreshTokenAsync(CancellationToken.None); var oauth2 = new SaslMechanismOAuth2(credential.UserId, credential.Token.AccessToken); #endregion #region 信件內容 var message = new MimeMessage(); //寄件者名稱及信箱(信箱是測試帳號) message.From.Add(new MailboxAddress(\u0026#34;bill\u0026#34;, \u0026#34;xxxx@gmail.com\u0026#34;)); //收件者名稱，收件者信箱 message.To.Add(new MailboxAddress(\u0026#34;billhuang\u0026#34;, \u0026#34;xxxx@gmail.com\u0026#34;)); //信件標題 message.Subject = \u0026#34;How you doing\u0026#39;?\u0026#34;; //信件內容 message.Body = new TextPart(\u0026#34;plain\u0026#34;) { Text = @\u0026#34;This is test\u0026#34; }; using (var client = new SmtpClient()) { await client.ConnectAsync(\u0026#34;smtp.gmail.com\u0026#34;, 587); await client.AuthenticateAsync(oauth2); await client.SendAsync(message); await client.DisconnectAsync(true); } #endregion return Ok(\u0026#34;OK\u0026#34;); } 執行結果 F5執行後，依照下列步驟操作，最後看到OK後，就可以去信箱確認有沒有收到信了。 MailKit為基於MimeKit解析器的客戶端函式庫 MimeKit為解析器，用於解析電子郵件格式\n參考 官方網站 官方GmailOauth2範例 Gmail教學\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-mailkit%E7%AF%84%E4%BE%8B/","summary":"目的 使用gmail寄信\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Google.Apis.Auth(使用google信箱時需要做oauth驗證才可以使用) MailKit(寄信) 編輯WeatherForecastController檔案 將預設的API註解 [HttpGet(\u0026#34;SendEmail\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get() { #region OAuth驗證 const string GMailAccount = \u0026#34;前置作業文章打上去的測試帳號\u0026#34;; var clientSecrets = new ClientSecrets { ClientId = \u0026#34;前置作業文章最後給的用戶ID\u0026#34;, ClientSecret = \u0026#34;前置作業文章最後給的用戶端密碼\u0026#34; }; var codeFlow = new GoogleAuthorizationCodeFlow(new GoogleAuthorizationCodeFlow.Initializer { DataStore = new FileDataStore(\u0026#34;CredentialCacheFolder\u0026#34;, false), Scopes = new[] { \u0026#34;https://mail.google.com/\u0026#34; }, ClientSecrets = clientSecrets }); var codeReceiver = new LocalServerCodeReceiver(); var authCode = new AuthorizationCodeInstalledApp(codeFlow, codeReceiver); var credential = await authCode.","title":"2022ITHelp dotnet6 MailKit範例"},{"content":"目的 前往google帳號設定OAuth，才能使用google帳號寄信\n點擊連結 到 google帳號管理\n新增專案 點擊如圖按鈕建立新專案 命名你的專案名稱，並點擊建立 設定OAuth 跟著紅框處點擊到OAuth同意畫面 點擊剛剛建立的專案 選擇外部，並點擊建立 編輯應用程式註冊申請畫面 將所有必填欄位填完 第二步直接下一步 新增使用者，要建立你要使用的帳號 摘要直接下一步 憑證 點建立憑證 點擊OAuth用戶端ID 應用程式類型選擇電腦版應用程式，填入名稱後點擊建立 最後會取得用戶端ID與用戶端密碼 結論 最後就可以進行MailKit的使用了，下一篇就可以使用ＭailKit\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-mailkit%E5%89%8D%E7%BD%AE%E4%BD%9C%E6%A5%AD/","summary":"目的 前往google帳號設定OAuth，才能使用google帳號寄信\n點擊連結 到 google帳號管理\n新增專案 點擊如圖按鈕建立新專案 命名你的專案名稱，並點擊建立 設定OAuth 跟著紅框處點擊到OAuth同意畫面 點擊剛剛建立的專案 選擇外部，並點擊建立 編輯應用程式註冊申請畫面 將所有必填欄位填完 第二步直接下一步 新增使用者，要建立你要使用的帳號 摘要直接下一步 憑證 點建立憑證 點擊OAuth用戶端ID 應用程式類型選擇電腦版應用程式，填入名稱後點擊建立 最後會取得用戶端ID與用戶端密碼 結論 最後就可以進行MailKit的使用了，下一篇就可以使用ＭailKit","title":"2022ITHelp dotnet6 MailKit前置作業"},{"content":"目的 透過強行別的模式使用appsetting設定檔資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 設定appsetting檔案 在appsetting新增一筆json資料\n\u0026#34;PersonalInformation\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;Bill\u0026#34;, \u0026#34;Age\u0026#34;: 20 } 新增model資料夾，並在裡面新增AppsettingConfig類別檔 編輯AppsettingConfig類別檔案 public class PersonalInformation { public PersonalInformation() { Name = string.Empty; } public string Name { get; set; } public int Age { get; set; } } 編輯Program.cs檔案 在program.cs中把appsetting的來源綁定在PersonalInformation這個class上\nbuilder.Services.Configure\u0026lt;PersonalInformation\u0026gt;( builder.Configuration.GetSection(\u0026#34;PersonalInformation\u0026#34;)); 注入所需要的地方 注入到預設的WeatherForecastController中，就可以使用。\nprivate readonly PersonalInformation _options; public WeatherForecastController(ILogger\u0026lt;WeatherForecastController\u0026gt; logger, IOptionsMonitor\u0026lt;PersonalInformation\u0026gt; options) { _logger = logger; _options = options.CurrentValue; } 此範例使用的是IOptionsMonitor\n選項模式 可使用singleton 重載 具名選項 IOptions V X X IOptionsSnapshot X V V IOptionsMonitor V V V 參考 選項模式 IOptions與IOptionsSnaphot與IOptionsMonitor 程式範例參考 options差別\n範例檔 GitHub\n","permalink":"https://ci-yu.top/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-%E5%8F%96%E5%BE%97appsettings%E6%AA%94%E6%A1%88/","summary":"目的 透過強行別的模式使用appsetting設定檔資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 設定appsetting檔案 在appsetting新增一筆json資料\n\u0026#34;PersonalInformation\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;Bill\u0026#34;, \u0026#34;Age\u0026#34;: 20 } 新增model資料夾，並在裡面新增AppsettingConfig類別檔 編輯AppsettingConfig類別檔案 public class PersonalInformation { public PersonalInformation() { Name = string.Empty; } public string Name { get; set; } public int Age { get; set; } } 編輯Program.cs檔案 在program.cs中把appsetting的來源綁定在PersonalInformation這個class上\nbuilder.Services.Configure\u0026lt;PersonalInformation\u0026gt;( builder.Configuration.GetSection(\u0026#34;PersonalInformation\u0026#34;)); 注入所需要的地方 注入到預設的WeatherForecastController中，就可以使用。\nprivate readonly PersonalInformation _options; public WeatherForecastController(ILogger\u0026lt;WeatherForecastController\u0026gt; logger, IOptionsMonitor\u0026lt;PersonalInformation\u0026gt; options) { _logger = logger; _options = options.CurrentValue; } 此範例使用的是IOptionsMonitor","title":"2022ITHelp dotnet6 取得appsettings檔案內容"}]