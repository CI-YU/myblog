[{"content":"近期專案上有個需求,需要使用opencc來將接收到的資料將簡體轉繁體,參考了will保哥與黑暗執行緒的範例,其中保哥的文章指出有做防止記憶體洩漏的調整,但上線後發現一樣有記憶體洩漏的問題,最後找到的解決方案是,應該要使用opencc的函式做記憶體釋放,而非使用C#的函式。\n調整前 using System.Runtime.InteropServices; using System.Text; public static class OpenCCHelper { [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_open\u0026#34;)] private static extern IntPtr opencc_open(string configFileName); [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_convert_utf8\u0026#34;)] private static extern IntPtr opencc_convert_utf8(IntPtr opencc, IntPtr input, long length); public static string ConvertFromSimplifiedToTraditional(this string text, string config = \u0026#34;s2t\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromSimplifiedToTraditionalTaiwan(this string text, string config = \u0026#34;s2twp\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromTraditionalTaiwanToSimplified(this string text, string config = \u0026#34;tw2sp\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromTraditionalToSimplified(this string text, string config = \u0026#34;t2s\u0026#34;) { return OpenCC(text, config: config); } public static string OpenCC(this string text, string config) { var configFile = $\u0026#34;C:\\\\Tools\\\\OpenCC\\\\share\\\\opencc\\\\{config}.json\u0026#34;; if (!File.Exists(configFile)) { throw new FileNotFoundException(\u0026#34;設定檔找不到\u0026#34;, configFile); } IntPtr opencc = opencc_open(configFile); try { int len = Encoding.UTF8.GetByteCount(text); byte[] buffer = new byte[len + 1]; Encoding.UTF8.GetBytes(text, 0, text.Length, buffer, 0); IntPtr inStr = Marshal.AllocHGlobal(buffer.Length); try { Marshal.Copy(buffer, 0, inStr, buffer.Length); IntPtr outStr = opencc_convert_utf8(opencc, inStr, -1); try { int outLen = 0; while (Marshal.ReadByte(outStr, outLen) != 0) ++outLen; byte[] outBuffer = new byte[outLen]; Marshal.Copy(outStr, outBuffer, 0, outBuffer.Length); return Encoding.UTF8.GetString(outBuffer); } finally { Marshal.FreeHGlobal(outStr); } } finally { Marshal.FreeHGlobal(inStr); } } finally { Marshal.FreeHGlobal(opencc); } } } 調整後 using System.Runtime.InteropServices; using System.Text; public static class OpenCCHelper { [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_open\u0026#34;)] private static extern IntPtr opencc_open(string configFileName); //傳入參數做調整 [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_convert_utf8\u0026#34;)] private static extern IntPtr opencc_convert_utf8(IntPtr opencc, IntPtr input, UIntPtr length); //新增 [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_convert_utf8_free\u0026#34;)] private static extern IntPtr opencc_convert_utf8_free(IntPtr str); //新增 [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_close\u0026#34;)] private static extern IntPtr opencc_close(IntPtr opencc); public static string ConvertFromSimplifiedToTraditional(this string text, string config = \u0026#34;s2t\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromSimplifiedToTraditionalTaiwan(this string text, string config = \u0026#34;s2twp\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromTraditionalTaiwanToSimplified(this string text, string config = \u0026#34;tw2sp\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromTraditionalToSimplified(this string text, string config = \u0026#34;t2s\u0026#34;) { return OpenCC(text, config: config); } public static string OpenCC(this string text, string config) { var configFile = $\u0026#34;C:\\\\Tools\\\\OpenCC\\\\share\\\\opencc\\\\{config}.json\u0026#34;; if (!File.Exists(configFile)) { throw new FileNotFoundException(\u0026#34;設定檔找不到\u0026#34;, configFile); } IntPtr opencc = opencc_open(configFile); try { IntPtr inputPtr = Marshal.StringToCoTaskMemUTF8(text); try { var input = text.ToCharArray(); UIntPtr length = new((uint)Encoding.UTF8.GetByteCount(input)); IntPtr resultPtr = opencc_convert_utf8(opencc, inputPtr, length); try { string? result = Marshal.PtrToStringUTF8(resultPtr); return result!; } finally { //改為使用Opencc內建的釋放資源函數 opencc_convert_utf8_free(resultPtr); } } finally { Marshal.FreeCoTaskMem(inputPtr); } } finally { //改為使用Opencc內建的釋放資源函數 opencc_close(opencc); } } } 最終結果 改善前 改善後 相關連結 OpenCC\nGitHub Repo 黑暗執行緒\nOpenCC 中文繁簡體轉換工具 使用 C# 整合 OpenCC 執行中文繁簡轉換 Will保哥\n如何在 Windows 打造 OpenCC 中文繁簡轉換工具 ","permalink":"http://localhost:1313/dotnet/opencc-memory-leak/","summary":"近期專案上有個需求,需要使用opencc來將接收到的資料將簡體轉繁體,參考了will保哥與黑暗執行緒的範例,其中保哥的文章指出有做防止記憶體洩漏的調整,但上線後發現一樣有記憶體洩漏的問題,最後找到的解決方案是,應該要使用opencc的函式做記憶體釋放,而非使用C#的函式。\n調整前 using System.Runtime.InteropServices; using System.Text; public static class OpenCCHelper { [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_open\u0026#34;)] private static extern IntPtr opencc_open(string configFileName); [DllImport(@\u0026#34;C:\\Tools\\opencc\\bin\\opencc.dll\u0026#34;, EntryPoint = \u0026#34;opencc_convert_utf8\u0026#34;)] private static extern IntPtr opencc_convert_utf8(IntPtr opencc, IntPtr input, long length); public static string ConvertFromSimplifiedToTraditional(this string text, string config = \u0026#34;s2t\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromSimplifiedToTraditionalTaiwan(this string text, string config = \u0026#34;s2twp\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromTraditionalTaiwanToSimplified(this string text, string config = \u0026#34;tw2sp\u0026#34;) { return OpenCC(text, config: config); } public static string ConvertFromTraditionalToSimplified(this string text, string config = \u0026#34;t2s\u0026#34;) { return OpenCC(text, config: config); } public static string OpenCC(this string text, string config) { var configFile = $\u0026#34;C:\\\\Tools\\\\OpenCC\\\\share\\\\opencc\\\\{config}.","title":"Opencc Memory Leak"},{"content":"dotnet 6 部署到docker忽然變很慢 最近在公司將dotnet 6 用docker-compose部署到測試機時忽然要等3-5分鐘，最後查證是因為我們在linux環境上有做mount遠端磁碟造成部署時間過長\n掛載的磁碟機沒有做資料夾分類所有檔案都在一個資料夾底下，在根目錄就有破百萬的檔案，導致container透過volume連到實體路徑時會讀取過久\n","permalink":"http://localhost:1313/posts/dockerslow/","summary":"dotnet 6 部署到docker忽然變很慢 最近在公司將dotnet 6 用docker-compose部署到測試機時忽然要等3-5分鐘，最後查證是因為我們在linux環境上有做mount遠端磁碟造成部署時間過長\n掛載的磁碟機沒有做資料夾分類所有檔案都在一個資料夾底下，在根目錄就有破百萬的檔案，導致container透過volume連到實體路徑時會讀取過久","title":"Dockerslow"},{"content":"在一間公司中花費在公司的時間高低與一個人聰明或不聰明的象限圖中,對於我們來說哪種人是更被需要的？ 聰明又願意加班 這種人才可遇不可求,肯定是首選,不討論\n不聰明又不願意加班 這種人才也是可遇不可求,肯定不選,不討論\n聰明與願意加班 通常情況下如果只能選擇一項,我會願意選擇聰明但不加班\n因為聰明人的會想辦法優化工作,提升自己的工作產能,所以產能是會持續增加\n但如果是單純願意加班的人,工作產能就是固定的,沒有辦法有所期待\n","permalink":"http://localhost:1313/softskills/%E6%99%82%E9%96%93%E8%88%87%E6%99%BA%E6%85%A7%E8%B1%A1%E9%99%90/","summary":"在一間公司中花費在公司的時間高低與一個人聰明或不聰明的象限圖中,對於我們來說哪種人是更被需要的？ 聰明又願意加班 這種人才可遇不可求,肯定是首選,不討論\n不聰明又不願意加班 這種人才也是可遇不可求,肯定不選,不討論\n聰明與願意加班 通常情況下如果只能選擇一項,我會願意選擇聰明但不加班\n因為聰明人的會想辦法優化工作,提升自己的工作產能,所以產能是會持續增加\n但如果是單純願意加班的人,工作產能就是固定的,沒有辦法有所期待","title":"時間與智慧象限"},{"content":"如何直接安裝到ios裝置 flutter build ios flutter install 選擇要安裝到哪個裝置 ","permalink":"http://localhost:1313/flutter/%E5%AE%89%E8%A3%9D%E5%88%B0%E6%89%8B%E6%A9%9F/","summary":"如何直接安裝到ios裝置 flutter build ios flutter install 選擇要安裝到哪個裝置 ","title":"安裝到手機"},{"content":"2024年度目標 學會使用copilot,增加coding效率 3月前使用flutter開發記帳軟體並且上架 7月前TOEIC金色證書 開始錄製廣播 ","permalink":"http://localhost:1313/posts/2024%E5%B9%B4%E5%BA%A6%E7%9B%AE%E6%A8%99/","summary":"2024年度目標 學會使用copilot,增加coding效率 3月前使用flutter開發記帳軟體並且上架 7月前TOEIC金色證書 開始錄製廣播 ","title":"2024年度目標"},{"content":"問題 當使用dapper呼叫postgresql時後,需要在in裡面查詢一批陣列會遇到下方的錯誤訊息\nvar Ids = [1,2,3,4]; DynamicParameters parameters = new(); parameters.Add(\u0026#34;Ids\u0026#34;, Ids); var strSQL = \u0026#34;\u0026#34;; strSQL +=\u0026#34;select * from Users where id in @Ids;\u0026#34; await dapper.QueryAsync(strSQL,parameters); 42601: syntax error at or near \u0026ldquo;$1\u0026rdquo;\\r\\n\\r\\nPOSITION: 81\n解法 改語法為any就可以解決這個問題。\nvar Ids = [1,2,3,4]; DynamicParameters parameters = new(); parameters.Add(\u0026#34;Ids\u0026#34;, Ids); var strSQL = \u0026#34;\u0026#34;; strSQL +=\u0026#34;select * from Users where id = any(@Ids);\u0026#34; await dapper.QueryAsync(strSQL,parameters); ","permalink":"http://localhost:1313/dotnet/dapper-postgresql-error/","summary":"問題 當使用dapper呼叫postgresql時後,需要在in裡面查詢一批陣列會遇到下方的錯誤訊息\nvar Ids = [1,2,3,4]; DynamicParameters parameters = new(); parameters.Add(\u0026#34;Ids\u0026#34;, Ids); var strSQL = \u0026#34;\u0026#34;; strSQL +=\u0026#34;select * from Users where id in @Ids;\u0026#34; await dapper.QueryAsync(strSQL,parameters); 42601: syntax error at or near \u0026ldquo;$1\u0026rdquo;\\r\\n\\r\\nPOSITION: 81\n解法 改語法為any就可以解決這個問題。\nvar Ids = [1,2,3,4]; DynamicParameters parameters = new(); parameters.Add(\u0026#34;Ids\u0026#34;, Ids); var strSQL = \u0026#34;\u0026#34;; strSQL +=\u0026#34;select * from Users where id = any(@Ids);\u0026#34; await dapper.QueryAsync(strSQL,parameters); ","title":"Dapper PostgreSQL Error"},{"content":"總算完成了三十天，有努力追完的一定都會發現很多的觀念想法都似曾相似，軟實力對於工程師是非常重要的技能，我們有做有努力的地方不要害怕讓老闆知道。，不要只埋頭苦幹，再來說老闆都沒有看到我們的努力。\n相信大家都聽過選擇比努力更重要，對我來說機會比薪資更重要，當機會來了要如何把握住，就算老闆不懂敏捷還是可以透過其他方式漸進式的導入。將每個專案都自己區分階段，頻繁與老闆核對需求，善用靈活的思考，換個方式但還是可以達成目標。\n學習新知識和技術，當踏上工程師的道路，永遠不要停止學習，不斷的遇到難題，不斷的解決難題，在失敗中成長，成功是每天不斷累積而來的。\n今年會參加鐵人賽也是因為老闆有提了自我提升計畫，希望主管可以自主提升。不斷的激勵自己，在撰寫文章期間也發現自己還有很多地方可以做得更好，希望大家都可以一起努力，不要浪費時間。謝謝大家。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E7%B8%BD%E7%B5%90/","summary":"總算完成了三十天，有努力追完的一定都會發現很多的觀念想法都似曾相似，軟實力對於工程師是非常重要的技能，我們有做有努力的地方不要害怕讓老闆知道。，不要只埋頭苦幹，再來說老闆都沒有看到我們的努力。\n相信大家都聽過選擇比努力更重要，對我來說機會比薪資更重要，當機會來了要如何把握住，就算老闆不懂敏捷還是可以透過其他方式漸進式的導入。將每個專案都自己區分階段，頻繁與老闆核對需求，善用靈活的思考，換個方式但還是可以達成目標。\n學習新知識和技術，當踏上工程師的道路，永遠不要停止學習，不斷的遇到難題，不斷的解決難題，在失敗中成長，成功是每天不斷累積而來的。\n今年會參加鐵人賽也是因為老闆有提了自我提升計畫，希望主管可以自主提升。不斷的激勵自己，在撰寫文章期間也發現自己還有很多地方可以做得更好，希望大家都可以一起努力，不要浪費時間。謝謝大家。","title":"2023ITHelp 總結"},{"content":"說了這麼多到底要不要做管理職呢？相信讀者一定會希望作者提供建議，我的建議是只要沒有做過管理職都去做看看。擔任管理職可以為個人職業生涯帶來無限的可能性。首先，它擴展了我們的視野，讓我們更深入地了解業務運作的流程，從而使我們對整個組織的運作有更全面的理解。其次，擔任管理職將為我們打開多元的職業選擇，不再僅限於某一特定領域，這意味著我們可以在職業生涯中探索更多可能性。\n擔任管理職也是一個學習和成長的機會。在這個角色中，我們將面對各種挑戰，學習如何解決問題，有效地管理團隊，並在壓力下做出關鍵決策。同時，這也讓我們更深入地了解高層決策的內幕，理解為什麼某些決策被做出，是否存在未曾考慮的關鍵因素。\n擔任管理職還有助於擴展人脈。我們將有更多的機會與不同部門的人合作，這有助於在不同領域建立更廣泛的人脈，這在未來創業或尋找合作夥伴時將非常有益。最後，管理職也有助於爭取更高的薪資，因為管理經驗是增加薪資的有效途徑之一。\n總考慮擔任管理職是一個值得深思熟慮的選擇。它為個人和職業生涯的發展提供了無限可能，為您的職業生涯增添了豐富多彩的色彩。希望這些觀點能幫助您在做出決策時更有信心。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E7%B5%90%E8%AB%96%E6%98%AF%E5%90%A6%E8%A6%81%E5%81%9A%E7%AE%A1%E7%90%86%E8%81%B7/","summary":"說了這麼多到底要不要做管理職呢？相信讀者一定會希望作者提供建議，我的建議是只要沒有做過管理職都去做看看。擔任管理職可以為個人職業生涯帶來無限的可能性。首先，它擴展了我們的視野，讓我們更深入地了解業務運作的流程，從而使我們對整個組織的運作有更全面的理解。其次，擔任管理職將為我們打開多元的職業選擇，不再僅限於某一特定領域，這意味著我們可以在職業生涯中探索更多可能性。\n擔任管理職也是一個學習和成長的機會。在這個角色中，我們將面對各種挑戰，學習如何解決問題，有效地管理團隊，並在壓力下做出關鍵決策。同時，這也讓我們更深入地了解高層決策的內幕，理解為什麼某些決策被做出，是否存在未曾考慮的關鍵因素。\n擔任管理職還有助於擴展人脈。我們將有更多的機會與不同部門的人合作，這有助於在不同領域建立更廣泛的人脈，這在未來創業或尋找合作夥伴時將非常有益。最後，管理職也有助於爭取更高的薪資，因為管理經驗是增加薪資的有效途徑之一。\n總考慮擔任管理職是一個值得深思熟慮的選擇。它為個人和職業生涯的發展提供了無限可能，為您的職業生涯增添了豐富多彩的色彩。希望這些觀點能幫助您在做出決策時更有信心。","title":"2023ITHelp 結論是否要做管理職？"},{"content":"前言\n軟體業一直以來都面臨著工程師短缺的問題。儘管現在擁有了許多強大的人工智慧（AI）工具，但它們仍無法完全取代軟體工程師，或者說無法完全取代任何職業。我的看法是，AI可能會先取代其他職業，然後才有可能取代工程師。因此，作為一名工程師，我認為這仍然是一個不錯的職業選擇。\nai的興起讓很多資深工程師變得更厲害，效率變得更好，因為ai可以提供一個方向卻需要透過經驗的累積去辨識真偽，新人也不用擔心，可以透過ai更快的學習到有用的知識，也可以透過ai看到不同的coding風格，最後如果無法辨識真偽，再向資深前輩諮詢就好。就像以前會不會用網際網路的工程師會有一個落差，未來一定要知道如何使用ai來輔助我們工作，才可以在效率上不落後其他人，\nAI的崛起使資深工程師變得更加強大，因為AI能夠提供方向，但仍需要透過多年的經驗來判斷其真偽。對於新手來說，也不必擔心，因為可以通過AI更快的學習知識，並且可以參考AI展示的不同coding風格。最終，如果無法區分真偽，還可以向資深前輩詢問意見。這有點像以前不會使用網際網路的工程師在效率上就差人一截，未來，我們都需要知道如何運用AI來輔助我們的工作，以確保我們在效率方面不被其他人超越。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E8%A1%8C%E6%A5%AD%E8%B6%A8%E5%8B%A2%E5%92%8C%E6%9C%AA%E4%BE%86%E5%B1%95%E6%9C%9B/","summary":"前言\n軟體業一直以來都面臨著工程師短缺的問題。儘管現在擁有了許多強大的人工智慧（AI）工具，但它們仍無法完全取代軟體工程師，或者說無法完全取代任何職業。我的看法是，AI可能會先取代其他職業，然後才有可能取代工程師。因此，作為一名工程師，我認為這仍然是一個不錯的職業選擇。\nai的興起讓很多資深工程師變得更厲害，效率變得更好，因為ai可以提供一個方向卻需要透過經驗的累積去辨識真偽，新人也不用擔心，可以透過ai更快的學習到有用的知識，也可以透過ai看到不同的coding風格，最後如果無法辨識真偽，再向資深前輩諮詢就好。就像以前會不會用網際網路的工程師會有一個落差，未來一定要知道如何使用ai來輔助我們工作，才可以在效率上不落後其他人，\nAI的崛起使資深工程師變得更加強大，因為AI能夠提供方向，但仍需要透過多年的經驗來判斷其真偽。對於新手來說，也不必擔心，因為可以通過AI更快的學習知識，並且可以參考AI展示的不同coding風格。最終，如果無法區分真偽，還可以向資深前輩詢問意見。這有點像以前不會使用網際網路的工程師在效率上就差人一截，未來，我們都需要知道如何運用AI來輔助我們的工作，以確保我們在效率方面不被其他人超越。","title":"2023ITHelp 行業趨勢和未來展望"},{"content":"前言\n手機應用程式已經成為企業和個人生活不可或缺的一部分。然而，要在兩個主要平台，Android和iOS，上開發應用程式卻帶來了不少挑戰。其中一個最重要的挑戰之一是如何在節省公司營運成本的同時，確保應用程式的高效運行和市場影響力。\n技術選擇：當下主流跨平台技術有兩個選擇，flutter跟react native，我選擇的是flutter，原因有幾點\n效能接近原生，代表我們的技術在相同的情況下，相較於react native不需要擔心效能問題，直白點寫的扣爛一點沒關係。 已經內建Material Design、Cupertino兩種UI設計風格，讓我們在開發初期就可以不用煩惱很多的UI設計與規範，再來設計是主觀的太容易被干擾，透過已經決定好的設定規範加以限制可以有效的降低彼此觀點不同的問題。 例如：JS中有standardjs可以讓大家格式化風格都一致，大家都不用爭，visual studio預設也有C#的格式化風格，都可以有效解決大家寫法不同的問題。\n","permalink":"http://localhost:1313/softskills/2023ithelp-app%E6%8A%80%E8%A1%93/","summary":"前言\n手機應用程式已經成為企業和個人生活不可或缺的一部分。然而，要在兩個主要平台，Android和iOS，上開發應用程式卻帶來了不少挑戰。其中一個最重要的挑戰之一是如何在節省公司營運成本的同時，確保應用程式的高效運行和市場影響力。\n技術選擇：當下主流跨平台技術有兩個選擇，flutter跟react native，我選擇的是flutter，原因有幾點\n效能接近原生，代表我們的技術在相同的情況下，相較於react native不需要擔心效能問題，直白點寫的扣爛一點沒關係。 已經內建Material Design、Cupertino兩種UI設計風格，讓我們在開發初期就可以不用煩惱很多的UI設計與規範，再來設計是主觀的太容易被干擾，透過已經決定好的設定規範加以限制可以有效的降低彼此觀點不同的問題。 例如：JS中有standardjs可以讓大家格式化風格都一致，大家都不用爭，visual studio預設也有C#的格式化風格，都可以有效解決大家寫法不同的問題。","title":"2023ITHelp App技術"},{"content":"前言\n隨著軟體領域的不斷演進，軟體架構技術也在不斷發展。傳統的單體式架構已經漸漸被微服務架構、容器化和無服務器運算等新興技術所取代。這些新技術不僅提供更高的靈活性，還能夠更好地滿足現代應用的需求。\n當企業規模越來越大，架構就顯得格外重要，在不影響線上服務的情況下，逐步改善整體架構，是本章節的重點。\nKISS：KISS的意思是盡量保持架構的簡潔性，越簡單越好。現今環境很常提到微服務，有沒有想過是否真的需要微服務呢？並不是大家都需要微服務才能撐起公司的業務，不是每個人流量都跟電商一樣，那如果流量沒那麼多，用單體式或許是更好的選擇。\n例如：曾經公司的工程師用微服務架構去開發一個新專案，當時建議工程師不要使用微服務，因為我們的流量沒有那麼大，用微服務只是砸自己的腳，最後專案使用人數不如預期，但因為採用微服務、架構複雜化導致維護起來的成本變很高。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E6%9E%B6%E6%A7%8B%E6%8A%80%E8%A1%93/","summary":"前言\n隨著軟體領域的不斷演進，軟體架構技術也在不斷發展。傳統的單體式架構已經漸漸被微服務架構、容器化和無服務器運算等新興技術所取代。這些新技術不僅提供更高的靈活性，還能夠更好地滿足現代應用的需求。\n當企業規模越來越大，架構就顯得格外重要，在不影響線上服務的情況下，逐步改善整體架構，是本章節的重點。\nKISS：KISS的意思是盡量保持架構的簡潔性，越簡單越好。現今環境很常提到微服務，有沒有想過是否真的需要微服務呢？並不是大家都需要微服務才能撐起公司的業務，不是每個人流量都跟電商一樣，那如果流量沒那麼多，用單體式或許是更好的選擇。\n例如：曾經公司的工程師用微服務架構去開發一個新專案，當時建議工程師不要使用微服務，因為我們的流量沒有那麼大，用微服務只是砸自己的腳，最後專案使用人數不如預期，但因為採用微服務、架構複雜化導致維護起來的成本變很高。","title":"2023ITHelp 架構技術"},{"content":"前言\n在之前的文章中，提到了我是一名主要使用C#的工程師。由於我們採用微軟技術，因此不可避免地需要使用微軟的一整套產品，包括Windows Server和SQL Server。然而，最近我們的公司已經開始將資料庫轉移到PostgreSQL。主要原因是微軟的授權費用相當昂貴，尤其當業務量增長時，費用變得令人望而卻步。在資料庫選擇上建議可以直接選擇使用MySQL或PostgreSQL。儘管語法上存在些微的差異，但基本上選擇這兩種無需授權的資料庫性能上不會有太大的差異。如果碰到性能問題，通常是因為優化不足，例如缺少基本的索引優化。此外，我們可以考慮在系統前端引入Redis作為快取，以及實施讀寫分離等優化策略。值得強調的是，優化不必一次完成，可以逐步進行，因此不需要將太多時間浪費在一次性的優化上。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E8%B3%87%E6%96%99%E5%BA%AB%E6%8A%80%E8%A1%93/","summary":"前言\n在之前的文章中，提到了我是一名主要使用C#的工程師。由於我們採用微軟技術，因此不可避免地需要使用微軟的一整套產品，包括Windows Server和SQL Server。然而，最近我們的公司已經開始將資料庫轉移到PostgreSQL。主要原因是微軟的授權費用相當昂貴，尤其當業務量增長時，費用變得令人望而卻步。在資料庫選擇上建議可以直接選擇使用MySQL或PostgreSQL。儘管語法上存在些微的差異，但基本上選擇這兩種無需授權的資料庫性能上不會有太大的差異。如果碰到性能問題，通常是因為優化不足，例如缺少基本的索引優化。此外，我們可以考慮在系統前端引入Redis作為快取，以及實施讀寫分離等優化策略。值得強調的是，優化不必一次完成，可以逐步進行，因此不需要將太多時間浪費在一次性的優化上。","title":"2023ITHelp 資料庫技術"},{"content":"前言\n身為後端工程師要懂的東西非常的廣，從技術選擇我是選擇C#只是因為第一間錄取的公司是使用這個技術，在這門技術上也是有很多可以進步的空間，選擇上建議團隊中技術一致為主。\n版本選擇：當初剛進入公司時技術都還是停留在ASP、Webform這些比較久遠的技術，很幸運當時主管沒有限制我使用的技術，所以直接從dotnet6開始起步。通常在選擇版本時都建議選擇TLS(Long Term Support)的版本，在今年十一月dotnet8會發布，是新的長期支援版本，會建議明年下半年才開始使用，因為在使用dotnet6的時候有遇到很多套件無法支援的問題，或是遇到bug無法處理，所以為了可以讓自己準時下班，不要太早投入最新的技術。\n例如：有伺服器需要安裝Ubuntu選擇了最新版本22.04，結果在安裝nginx時發現無法安裝最新穩定版的nginx1.24，只能使用預設1.18版本，原因是新版本的nginx相依的套件還無法支援Ubuntu22.04\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%BE%8C%E7%AB%AF%E6%8A%80%E8%A1%93/","summary":"前言\n身為後端工程師要懂的東西非常的廣，從技術選擇我是選擇C#只是因為第一間錄取的公司是使用這個技術，在這門技術上也是有很多可以進步的空間，選擇上建議團隊中技術一致為主。\n版本選擇：當初剛進入公司時技術都還是停留在ASP、Webform這些比較久遠的技術，很幸運當時主管沒有限制我使用的技術，所以直接從dotnet6開始起步。通常在選擇版本時都建議選擇TLS(Long Term Support)的版本，在今年十一月dotnet8會發布，是新的長期支援版本，會建議明年下半年才開始使用，因為在使用dotnet6的時候有遇到很多套件無法支援的問題，或是遇到bug無法處理，所以為了可以讓自己準時下班，不要太早投入最新的技術。\n例如：有伺服器需要安裝Ubuntu選擇了最新版本22.04，結果在安裝nginx時發現無法安裝最新穩定版的nginx1.24，只能使用預設1.18版本，原因是新版本的nginx相依的套件還無法支援Ubuntu22.04","title":"2023ITHelp 後端技術"},{"content":"前言\n溝通是成功不可或缺的技巧，不管是對主管、同事、客戶、還是商業合作夥伴，都可以有效提升在職場的表現，也能很好的改善辦公室氣氛，工程師最缺的就是溝通技巧，要成為優秀的技術經理，一定要在溝通技巧上多加琢磨，才能會得更大的成就。\n聽：當任何人與你討論時，聽懂對方想表達的內容是很重要的事情。\n整合：當瞭解對方所表達的內容時，用最短的句子整理出對方所要說的重點，幫助確認是否認知上有誤會。\n處理情緒：在溝通與討論的期間，一定會遇到觀點不合有火氣的時候，當下建議先深呼吸舒緩情緒，有情緒只會變成無謂的爭執，重點應該要放在這次討論要解決的問題，達成目的是目標。\n察言觀色：懂的察言觀色可以幫助理解對方的想法，透過臉部表情、身體語言等等細微的變化更容易了解對方。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E6%BA%9D%E9%80%9A%E6%8A%80%E5%B7%A7/","summary":"前言\n溝通是成功不可或缺的技巧，不管是對主管、同事、客戶、還是商業合作夥伴，都可以有效提升在職場的表現，也能很好的改善辦公室氣氛，工程師最缺的就是溝通技巧，要成為優秀的技術經理，一定要在溝通技巧上多加琢磨，才能會得更大的成就。\n聽：當任何人與你討論時，聽懂對方想表達的內容是很重要的事情。\n整合：當瞭解對方所表達的內容時，用最短的句子整理出對方所要說的重點，幫助確認是否認知上有誤會。\n處理情緒：在溝通與討論的期間，一定會遇到觀點不合有火氣的時候，當下建議先深呼吸舒緩情緒，有情緒只會變成無謂的爭執，重點應該要放在這次討論要解決的問題，達成目的是目標。\n察言觀色：懂的察言觀色可以幫助理解對方的想法，透過臉部表情、身體語言等等細微的變化更容易了解對方。","title":"2023ITHelp 溝通技巧"},{"content":"前言\n一個人運氣好壞也是一個很重要的事情，在換工作的時候，剛好部門遇到大震盪，部門主管被裁，身邊的工程師、系統分析師、產品經理陸續離開，以年資來說我的確很難有機會在這個時間點做到管理職，但是當機會來的時候有沒有辦法好好把握，就是關鍵了，必續更加快速地進入狀態，準確地抓住老闆的痛點並加以解決，這也呼應了限制理論，造成瓶頸的只有一個點，每次都解決一個點，久了就可以把老闆的煩惱都解決，那自然的你又創造了下一次的機會。\n運氣可以提供一個好的開始，但最終的成功取決於我們的努力與毅力，我們需要做到的是相信自己的能力，不斷學習成長，積極的尋找機會，創造機會，越是努力會發現運氣越好，運氣是我們不能控制的，我們可以控制的是我們要不要努力，所以還是要把握時間多努力。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E9%81%8B%E6%B0%A3%E8%88%87%E5%8A%AA%E5%8A%9B/","summary":"前言\n一個人運氣好壞也是一個很重要的事情，在換工作的時候，剛好部門遇到大震盪，部門主管被裁，身邊的工程師、系統分析師、產品經理陸續離開，以年資來說我的確很難有機會在這個時間點做到管理職，但是當機會來的時候有沒有辦法好好把握，就是關鍵了，必續更加快速地進入狀態，準確地抓住老闆的痛點並加以解決，這也呼應了限制理論，造成瓶頸的只有一個點，每次都解決一個點，久了就可以把老闆的煩惱都解決，那自然的你又創造了下一次的機會。\n運氣可以提供一個好的開始，但最終的成功取決於我們的努力與毅力，我們需要做到的是相信自己的能力，不斷學習成長，積極的尋找機會，創造機會，越是努力會發現運氣越好，運氣是我們不能控制的，我們可以控制的是我們要不要努力，所以還是要把握時間多努力。","title":"2023ITHelp 運氣與努力"},{"content":"前言\n在競爭激烈的職場中，不斷提升自己的能力至關重要，自我反省和持續改善是讓自己可以不斷的成長的關鍵元素，本文中將討論如何實現。\n自我反省的重要性：\n自我反省是一個很有趣的思考過程，透過它我們可以更深刻的了解自己，包誇我們的優勢與弱勢。\n了解自己：了解自己的優勢與弱勢，發揮優勢，改善弱勢，用旁觀者的角度或對方的角度來思考自己每次的決定與行動是否有可以改善的地方，\n我的優勢是年輕大家對於犯錯都比較有容忍度，詢問問題大多數人都願意給予年輕人意見\n我的弱勢是語言能力，團隊有外國人沒有辦法用英文快速的溝通，所以花費很多時間在做溝通\n持續改善：當知道自己的問題後，接下來就是要面對與改善，改變的路是困難的想必大家都知道，但唯有持續改善，才能成為更優秀得人才。\n堅持：持續改善需要堅韌不拔的毅力，不斷的改變。\n學習：持續學習周遭所有人的優點，每個人都有優點，一場會議，誰表現得好，為什麼好，學起來，誰表現得不好，為什麼不好，謹惕自己。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E8%87%AA%E6%88%91%E5%8F%8D%E7%9C%81%E8%88%87%E6%8C%81%E7%BA%8C%E6%94%B9%E5%96%84/","summary":"前言\n在競爭激烈的職場中，不斷提升自己的能力至關重要，自我反省和持續改善是讓自己可以不斷的成長的關鍵元素，本文中將討論如何實現。\n自我反省的重要性：\n自我反省是一個很有趣的思考過程，透過它我們可以更深刻的了解自己，包誇我們的優勢與弱勢。\n了解自己：了解自己的優勢與弱勢，發揮優勢，改善弱勢，用旁觀者的角度或對方的角度來思考自己每次的決定與行動是否有可以改善的地方，\n我的優勢是年輕大家對於犯錯都比較有容忍度，詢問問題大多數人都願意給予年輕人意見\n我的弱勢是語言能力，團隊有外國人沒有辦法用英文快速的溝通，所以花費很多時間在做溝通\n持續改善：當知道自己的問題後，接下來就是要面對與改善，改變的路是困難的想必大家都知道，但唯有持續改善，才能成為更優秀得人才。\n堅持：持續改善需要堅韌不拔的毅力，不斷的改變。\n學習：持續學習周遭所有人的優點，每個人都有優點，一場會議，誰表現得好，為什麼好，學起來，誰表現得不好，為什麼不好，謹惕自己。","title":"2023ITHelp 自我反省與持續改善"},{"content":"前言\n在高壓的工作環境裡如何在生活中取得平衡是相當重要的事情，適度的休息可以增加我們的產能也能幫助我們進一步的突破自己的極限，職場是場耐力賽怎麼針對自己進行配速來贏得比賽，本文會提供一些方法。\n釋放壓力：剛上任管理職是難免會感到壓力的，許多時候我們會感覺自己被壓得透不過氣來。在這種情況下，多運動是最迅速且有效的方法。運動時，我們可以完全忘卻煩惱，專注於身體的運動和呼吸。此外，多與周遭的人聊聊天也能幫助釋放壓力，找個朋友或同事聊聊天，坦誠的表達一下自己對當天工作中的不滿或與討人厭的同事之間的衝突感受，這有助於情緒的宣洩和情感的舒緩。\n安排休假：週末放假建議找自己喜歡的事情做，不管是外出旅遊或是宅在家裡打電動都可以，也可以安排親子活動增加親子間的感情。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E7%94%9F%E6%B4%BB%E5%B9%B3%E8%A1%A1/","summary":"前言\n在高壓的工作環境裡如何在生活中取得平衡是相當重要的事情，適度的休息可以增加我們的產能也能幫助我們進一步的突破自己的極限，職場是場耐力賽怎麼針對自己進行配速來贏得比賽，本文會提供一些方法。\n釋放壓力：剛上任管理職是難免會感到壓力的，許多時候我們會感覺自己被壓得透不過氣來。在這種情況下，多運動是最迅速且有效的方法。運動時，我們可以完全忘卻煩惱，專注於身體的運動和呼吸。此外，多與周遭的人聊聊天也能幫助釋放壓力，找個朋友或同事聊聊天，坦誠的表達一下自己對當天工作中的不滿或與討人厭的同事之間的衝突感受，這有助於情緒的宣洩和情感的舒緩。\n安排休假：週末放假建議找自己喜歡的事情做，不管是外出旅遊或是宅在家裡打電動都可以，也可以安排親子活動增加親子間的感情。","title":"2023ITHelp 生活平衡"},{"content":"前言\n當上管理職後，會有除了寫程式以外的事情需要去努力，其中建立個人品牌和影響力是相當重要的事情，試想一件衣服如果有了品牌的光環，是不是它的價值就不一樣了，我們可以透過很多方法去執行\n參與社群：多參與社群可以遇到很多的同好，大家互相分享技術聊聊最近有什麼有趣的新技術，提升自己的知名度。\n發表文章：工程師寫文章在blog上是相當簡單的一件事情，我們可以透過網路的輔助，提供一個機會讓自己被看見，大家有沒有看過保哥的文章，正是透過這種方式接到lativ的案子，不要去想自己寫的太差還是不要發文了，多寫文章是幫助自己釐清自己所學。\n分享：在公司多分享自己的技術多幫助各部門的同仁，把每一位同事都當做自己的人脈，營造出好口碑，或許有一天他就是你的機會。\n例如：曾經我們配合的廠商就有傳訊息來詢問有位應徵者在我們公司的業務單位任職想打聽這位應徵者的狀況。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%BB%BA%E7%AB%8B%E5%80%8B%E4%BA%BA%E5%93%81%E7%89%8C%E5%92%8C%E5%BD%B1%E9%9F%BF%E5%8A%9B/","summary":"前言\n當上管理職後，會有除了寫程式以外的事情需要去努力，其中建立個人品牌和影響力是相當重要的事情，試想一件衣服如果有了品牌的光環，是不是它的價值就不一樣了，我們可以透過很多方法去執行\n參與社群：多參與社群可以遇到很多的同好，大家互相分享技術聊聊最近有什麼有趣的新技術，提升自己的知名度。\n發表文章：工程師寫文章在blog上是相當簡單的一件事情，我們可以透過網路的輔助，提供一個機會讓自己被看見，大家有沒有看過保哥的文章，正是透過這種方式接到lativ的案子，不要去想自己寫的太差還是不要發文了，多寫文章是幫助自己釐清自己所學。\n分享：在公司多分享自己的技術多幫助各部門的同仁，把每一位同事都當做自己的人脈，營造出好口碑，或許有一天他就是你的機會。\n例如：曾經我們配合的廠商就有傳訊息來詢問有位應徵者在我們公司的業務單位任職想打聽這位應徵者的狀況。","title":"2023ITHelp 建立個人品牌和影響力"},{"content":"前言\n當上主管後勢必會面臨許多的困難與挫折，要如何在每一次的失敗中吸取經驗，就是我們要學習的。\n兩次失敗的改版\n職業生涯的某個時刻，負責主要服務的首次改版，我們熱衷的推出新功能以滿足用戶需求然而事情並沒有想像中的順利。\n首次上線，由於工程師程式邏輯錯誤，導致服務無法正常運作，引發大量用戶的抱怨及不滿。\n二次上線，遇到了新的挑戰，雖然邏輯問題已經被修正，但卻遇到效能問題，這次老闆建議暫緩上線，待修復效能問題後再進行上線，因為已經失敗兩次，我不願意我不願意再次延期，而這次的決定被老闆嚴厲的批評，身為主管不應該帶入個人情緒，應該以團隊為優先考量。\n教訓和應對策略\n總是會遇到不如預期的事情，難免會沮喪、焦慮或失望，但我們應該接受挫折並保持冷靜，冷靜有助於我們更好的面對挫折。\n發現問題並尋找解決方案\n未詳細測試：當時公司是沒有完善的測試流程，但我們可以先依靠人工測試來解決問題，雖然人工測試看似不完美，但能解決問題就是好方法。\n未安排壓力測試：公司一樣沒有完整的壓力測試流程，但發現這個問題，才讓我們團隊後續開始使用K6來做第一輪的壓力測試。\n結語\n持續的克服困難與挫折是我們展現價值的必經之路。\n三個步驟：冷靜，發現問題，解決問題。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%85%8B%E6%9C%8D%E5%9B%B0%E9%9B%A3%E5%92%8C%E6%8C%AB%E6%8A%98/","summary":"前言\n當上主管後勢必會面臨許多的困難與挫折，要如何在每一次的失敗中吸取經驗，就是我們要學習的。\n兩次失敗的改版\n職業生涯的某個時刻，負責主要服務的首次改版，我們熱衷的推出新功能以滿足用戶需求然而事情並沒有想像中的順利。\n首次上線，由於工程師程式邏輯錯誤，導致服務無法正常運作，引發大量用戶的抱怨及不滿。\n二次上線，遇到了新的挑戰，雖然邏輯問題已經被修正，但卻遇到效能問題，這次老闆建議暫緩上線，待修復效能問題後再進行上線，因為已經失敗兩次，我不願意我不願意再次延期，而這次的決定被老闆嚴厲的批評，身為主管不應該帶入個人情緒，應該以團隊為優先考量。\n教訓和應對策略\n總是會遇到不如預期的事情，難免會沮喪、焦慮或失望，但我們應該接受挫折並保持冷靜，冷靜有助於我們更好的面對挫折。\n發現問題並尋找解決方案\n未詳細測試：當時公司是沒有完善的測試流程，但我們可以先依靠人工測試來解決問題，雖然人工測試看似不完美，但能解決問題就是好方法。\n未安排壓力測試：公司一樣沒有完整的壓力測試流程，但發現這個問題，才讓我們團隊後續開始使用K6來做第一輪的壓力測試。\n結語\n持續的克服困難與挫折是我們展現價值的必經之路。\n三個步驟：冷靜，發現問題，解決問題。","title":"2023ITHelp 克服困難和挫折"},{"content":"前言\n無論是大型企業或是小型企業，都需要具備危機管理和風險控制的能力，本章會討論如何建立團隊防護網，應對各種挑戰。\n風險評估：定期評估當人員異動時，會對團隊造成什麼影響，要花費多少時間才可以回復原有水準。\n例如：大家都各自負責一個項目，技術分散，也沒有任何文件，當團隊中有任何人畢業，很明顯會遭遇到很大的停滯期，如果技術又很不信的是古董，這個停滯期肯定會拉得更長。\n定期關懷：平常就要關心團隊成員，不要等到人要走了才來關心，已經來不及了就像變了心的女朋友，回不來了。\n標準作業流程：當遇到未知問題時要做到臨危不亂的關鍵是一套作業流程，\n例如：系統忽然故障，要先請mis排查，還是無法解決找到相關工程師協助，先以能恢復正常為主，再來檢查問題，在執行同時要回報主管。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%8D%B1%E6%A9%9F%E7%AE%A1%E7%90%86%E5%92%8C%E9%A2%A8%E9%9A%AA%E6%8E%A7%E5%88%B6/","summary":"前言\n無論是大型企業或是小型企業，都需要具備危機管理和風險控制的能力，本章會討論如何建立團隊防護網，應對各種挑戰。\n風險評估：定期評估當人員異動時，會對團隊造成什麼影響，要花費多少時間才可以回復原有水準。\n例如：大家都各自負責一個項目，技術分散，也沒有任何文件，當團隊中有任何人畢業，很明顯會遭遇到很大的停滯期，如果技術又很不信的是古董，這個停滯期肯定會拉得更長。\n定期關懷：平常就要關心團隊成員，不要等到人要走了才來關心，已經來不及了就像變了心的女朋友，回不來了。\n標準作業流程：當遇到未知問題時要做到臨危不亂的關鍵是一套作業流程，\n例如：系統忽然故障，要先請mis排查，還是無法解決找到相關工程師協助，先以能恢復正常為主，再來檢查問題，在執行同時要回報主管。","title":"2023ITHelp 危機管理和風險控制"},{"content":"前言\n當部門在公司內部不被信任時，做任何事情都會很困難，要如何改善這個情況就是本章節要說的。\n找出問題點：羅馬不是一天造成的，部門不被信任也不是一天造成的，一定都是日積月累讓原本信任你的人也變得不信任，所以要先找出關鍵點加以改善。\n例如：條列出問題，如下方式，並依序解決。\n改版時常有問題：每次改版都有問題，不是沒改好就是改了電腦版但APP卻沒有改到\n例如：改版前與所有人同步要改版的內容，並且列出要測試的內容，如果有單元測試整合測試更好，我這只有人工測試但也沒關係有測總比沒測好。\n無法與非技術人員溝通：與非資訊部同仁溝通時，沒有調整說話內容會讓同事無法理解資訊部所做的事情。\n例如：我會善用譬喻法用舉例來說明，多利用生活的例子或是同仁的專業進行說明，可以讓非技術同仁更加容易的了解情況。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E9%83%A8%E9%96%80%E8%81%B2%E8%AD%BD/","summary":"前言\n當部門在公司內部不被信任時，做任何事情都會很困難，要如何改善這個情況就是本章節要說的。\n找出問題點：羅馬不是一天造成的，部門不被信任也不是一天造成的，一定都是日積月累讓原本信任你的人也變得不信任，所以要先找出關鍵點加以改善。\n例如：條列出問題，如下方式，並依序解決。\n改版時常有問題：每次改版都有問題，不是沒改好就是改了電腦版但APP卻沒有改到\n例如：改版前與所有人同步要改版的內容，並且列出要測試的內容，如果有單元測試整合測試更好，我這只有人工測試但也沒關係有測總比沒測好。\n無法與非技術人員溝通：與非資訊部同仁溝通時，沒有調整說話內容會讓同事無法理解資訊部所做的事情。\n例如：我會善用譬喻法用舉例來說明，多利用生活的例子或是同仁的專業進行說明，可以讓非技術同仁更加容易的了解情況。","title":"2023ITHelp 部門聲譽"},{"content":"前言\n在競爭激烈的商業環境中，對市場的敏銳觸覺扮演著關鍵的角色。它使我們能夠提前洞悉需求端的動向，這樣我們就可以提前進行分析和準備，避免了需求方和我們之間的誤解和時間浪費。由於我們是執行單位，能夠直接評估可執行性，這有助於加速公司的決策過程，使我們更快地響應市場變化，並實現更快的行動。这不僅提高了效率，也有助於公司在競爭激烈的環境中保持競爭優勢。\n尋找機會：抓住市場的變化，並早於需求方制定整體方向，一方面提早準備，一方面這也是表現的機會。\n例如：當openai剛開始盛行時，提早開始了解openai api服務，當老闆提出想要導入ai服務時，已經有解決方案可以與老闆直接討論。\n競爭優勢：要時時刻刻去觀察同業的產品，了解同業為什麼要做這類的改動，帶來的好處是什麼，我們可以添加什麼調整讓整個改動變得更優於對方。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%9F%B9%E9%A4%8A%E5%B0%8D%E6%A5%AD%E5%8B%99%E5%92%8C%E5%B8%82%E5%A0%B4%E7%9A%84%E6%95%8F%E9%8A%B3%E8%A7%B8%E8%A6%BA/","summary":"前言\n在競爭激烈的商業環境中，對市場的敏銳觸覺扮演著關鍵的角色。它使我們能夠提前洞悉需求端的動向，這樣我們就可以提前進行分析和準備，避免了需求方和我們之間的誤解和時間浪費。由於我們是執行單位，能夠直接評估可執行性，這有助於加速公司的決策過程，使我們更快地響應市場變化，並實現更快的行動。这不僅提高了效率，也有助於公司在競爭激烈的環境中保持競爭優勢。\n尋找機會：抓住市場的變化，並早於需求方制定整體方向，一方面提早準備，一方面這也是表現的機會。\n例如：當openai剛開始盛行時，提早開始了解openai api服務，當老闆提出想要導入ai服務時，已經有解決方案可以與老闆直接討論。\n競爭優勢：要時時刻刻去觀察同業的產品，了解同業為什麼要做這類的改動，帶來的好處是什麼，我們可以添加什麼調整讓整個改動變得更優於對方。","title":"2023ITHelp 培養對業務和市場的敏銳觸覺"},{"content":"前言\n競爭激烈的商業環境中，了解公司的戰略和願景是實現個人和職業成功的重要一步。公司的戰略和願景是企業的指南，它們影響著企業的每個層面，從營銷到運營，再到文化和價值觀。本文將深入探討為什麼了解公司的戰略和願景如此重要，以及如何將這一了解轉化為成功的機會。\n公司戰略\n方向指南： 公司戰略確定了企業的長期目標和方向。了解這些目標有助於個人明確自己的工作如何貢獻到整體目標。 資源分配： 公司戰略決定了資源的分配方式。了解戰略可以幫助個人了解哪些項目或部門可能會受到更多的投資，從而影響到個人的工作。 競爭優勢： 公司戰略通常包括獲得競爭優勢的計劃。了解這些計劃可以幫助個人更好地理解市場動態，有助於個人的職業發展。 公司願景\n閱讀公司文件： 公司通常會在官方文件中公布其戰略計劃和願景。這些文件可以是年度報告、網站內容或內部通訊。 參與內部會議： 越高階的職位越有機會參加高層的會議，善用這個優勢了解公司願景。 與同事交流： 與同事交流可以瞭解他們對公司戰略和願景的看法。這種分享意見的機會可以拓寬個人的視野。 ","permalink":"http://localhost:1313/softskills/2023ithelp-%E4%BA%86%E8%A7%A3%E5%85%AC%E5%8F%B8%E6%88%B0%E7%95%A5%E5%92%8C%E9%A1%98%E6%99%AF/","summary":"前言\n競爭激烈的商業環境中，了解公司的戰略和願景是實現個人和職業成功的重要一步。公司的戰略和願景是企業的指南，它們影響著企業的每個層面，從營銷到運營，再到文化和價值觀。本文將深入探討為什麼了解公司的戰略和願景如此重要，以及如何將這一了解轉化為成功的機會。\n公司戰略\n方向指南： 公司戰略確定了企業的長期目標和方向。了解這些目標有助於個人明確自己的工作如何貢獻到整體目標。 資源分配： 公司戰略決定了資源的分配方式。了解戰略可以幫助個人了解哪些項目或部門可能會受到更多的投資，從而影響到個人的工作。 競爭優勢： 公司戰略通常包括獲得競爭優勢的計劃。了解這些計劃可以幫助個人更好地理解市場動態，有助於個人的職業發展。 公司願景\n閱讀公司文件： 公司通常會在官方文件中公布其戰略計劃和願景。這些文件可以是年度報告、網站內容或內部通訊。 參與內部會議： 越高階的職位越有機會參加高層的會議，善用這個優勢了解公司願景。 與同事交流： 與同事交流可以瞭解他們對公司戰略和願景的看法。這種分享意見的機會可以拓寬個人的視野。 ","title":"2023ITHelp 了解公司戰略和願景"},{"content":"前言\n工程師沒有進步對公司部門與自身都是很嚴重的問題，不要讓工程師只有年資沒有實力，分享與互相學習的文化能夠提高團隊的創造力和競爭力。本文將說明如何建立這種文化。\n分享會：創造一個可以讓大家學習知識的時間，讓大家在工作期間可以稍做放鬆，只要有人願意分享他們的知識時，每個人都有機會學習到新的東西，也可以獲得放鬆的機會。建議增加主題的多樣性，讓前端與後端可以有更多的機會做交流，讓參與者可以獲得不同領域的專業知識。\n第一次由我開始，簡單的介紹資料庫效能優化，什麼是索引，索引可以來做什麼，第二次由另一位工程師負責，介紹Git以及如何使用，每一次的分享除了可以讓部門更有凝聚力，也可以透過引導式提問，讓部門開始學習如何問問題，大家各自擅長什麼，鼓勵有問題就立刻提出來，大家一起解決。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%88%86%E4%BA%AB%E8%88%87%E4%BA%92%E7%9B%B8%E5%AD%B8%E7%BF%92%E7%9A%84%E6%96%87%E5%8C%96/","summary":"前言\n工程師沒有進步對公司部門與自身都是很嚴重的問題，不要讓工程師只有年資沒有實力，分享與互相學習的文化能夠提高團隊的創造力和競爭力。本文將說明如何建立這種文化。\n分享會：創造一個可以讓大家學習知識的時間，讓大家在工作期間可以稍做放鬆，只要有人願意分享他們的知識時，每個人都有機會學習到新的東西，也可以獲得放鬆的機會。建議增加主題的多樣性，讓前端與後端可以有更多的機會做交流，讓參與者可以獲得不同領域的專業知識。\n第一次由我開始，簡單的介紹資料庫效能優化，什麼是索引，索引可以來做什麼，第二次由另一位工程師負責，介紹Git以及如何使用，每一次的分享除了可以讓部門更有凝聚力，也可以透過引導式提問，讓部門開始學習如何問問題，大家各自擅長什麼，鼓勵有問題就立刻提出來，大家一起解決。","title":"2023ITHelp 分享與互相學習的文化"},{"content":"前言\n在組織內部，良好的溝通管道對於整個團隊的發展和協作至關重要，它們不僅有助於工程師將感受傳達給管理層，還能確保主管能有效的傳遞訊息給員工。\n提高透明度：透明度是建立信任與減少猜忌和誤解的基石，可以透過每個月與部門說明主管會議內容。讓整個部門可以了解高層決策的背後動機，可以有效減少了不必要的誤解。\n定期會議：制定每週會議或月會，讓整個團隊可以共同討論問題，分享資訊、解決問題，這場會議提供了一個開放的平台，鼓勵員工分享意見與提出問題。\n多樣化的管道：讓員工可以透過訊息、信件、會議確保任何人都可以接收到訊息。\n開放的文化：鼓勵開放和坦承的對話，員工可以自由表達觀點，不必擔心後果。這種文化可以鼓勵員工創新和建設性的討論，讓員工感受到被重視，有助於提高團隊效率。\n讓員工認為主管只會解決提出問的人來減少問題，是不聰明的行為。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E8%89%AF%E5%A5%BD%E7%9A%84%E6%BA%9D%E9%80%9A%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%8D%E9%A5%8B%E6%A9%9F%E5%88%B6/","summary":"前言\n在組織內部，良好的溝通管道對於整個團隊的發展和協作至關重要，它們不僅有助於工程師將感受傳達給管理層，還能確保主管能有效的傳遞訊息給員工。\n提高透明度：透明度是建立信任與減少猜忌和誤解的基石，可以透過每個月與部門說明主管會議內容。讓整個部門可以了解高層決策的背後動機，可以有效減少了不必要的誤解。\n定期會議：制定每週會議或月會，讓整個團隊可以共同討論問題，分享資訊、解決問題，這場會議提供了一個開放的平台，鼓勵員工分享意見與提出問題。\n多樣化的管道：讓員工可以透過訊息、信件、會議確保任何人都可以接收到訊息。\n開放的文化：鼓勵開放和坦承的對話，員工可以自由表達觀點，不必擔心後果。這種文化可以鼓勵員工創新和建設性的討論，讓員工感受到被重視，有助於提高團隊效率。\n讓員工認為主管只會解決提出問的人來減少問題，是不聰明的行為。","title":"2023ITHelp 良好的溝通管道和反饋機制"},{"content":"前言\n事實上老闆只看結果，上線失敗你說你多麼努力用多少新技術都是多餘的，建立成果導向的團隊文化是一個選項\n理解成果導向的含義:首先，團隊成員應該明確理解成果導向的含義。這意味著將焦點放在實現目標、完成任務和取得結果上，而不僅僅是花時間和精力在流程上。成果導向的文化要求每個成員都對自己的工作負責，確保他們的貢獻最終能夠產生實際的價值。\n設定明確的目標和期望:建立成果導向的團隊文化需要明確的目標和期望。團隊成員應該知道他們正在追求什麼，並且應該明確了解他們的工作如何貢獻到這些目標的實現。領導者應該確保目標明確、可測量和有挑戰性，並鼓勵團隊成員專注於實現這些目標。\n例如：在這次的專案我們不但要完成需求還要在這次的專案透過prometheus將監測內容繪製到Garfana，為了在下次專案進行中可以更精準的知道我們程式的效能。\n例如：在這次的專案我們完成專案是基本的，那要在這次用K6來做壓力測試，一樣把結果繪製到Garfana上。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E6%88%90%E6%9E%9C%E5%B0%8E%E5%90%91%E7%9A%84%E5%9C%98%E9%9A%8A%E6%96%87%E5%8C%96/","summary":"前言\n事實上老闆只看結果，上線失敗你說你多麼努力用多少新技術都是多餘的，建立成果導向的團隊文化是一個選項\n理解成果導向的含義:首先，團隊成員應該明確理解成果導向的含義。這意味著將焦點放在實現目標、完成任務和取得結果上，而不僅僅是花時間和精力在流程上。成果導向的文化要求每個成員都對自己的工作負責，確保他們的貢獻最終能夠產生實際的價值。\n設定明確的目標和期望:建立成果導向的團隊文化需要明確的目標和期望。團隊成員應該知道他們正在追求什麼，並且應該明確了解他們的工作如何貢獻到這些目標的實現。領導者應該確保目標明確、可測量和有挑戰性，並鼓勵團隊成員專注於實現這些目標。\n例如：在這次的專案我們不但要完成需求還要在這次的專案透過prometheus將監測內容繪製到Garfana，為了在下次專案進行中可以更精準的知道我們程式的效能。\n例如：在這次的專案我們完成專案是基本的，那要在這次用K6來做壓力測試，一樣把結果繪製到Garfana上。","title":"2023ITHelp 成果導向的團隊文化"},{"content":"前言\n要如何讓下屬發揮100%的能力甚至超過100%呢？很可惜我們沒有程式鼓勵員這個職位，只能自己下來鼓勵同仁來達到目標\n反饋：每一次的專案完成或進行中，適當的提供意見反饋，告知工程師如何進行可以做的更好，哪些點可能還需要再多做確認。\n責任：給予工程師適當的責任，可以透過言語的暗示，讓工程師感受到被認可與重視。\n例如：這個部分就交給你負責了，我相信你可以做到。\n目標：每次的案子都為工程師量身定制他的個人成長目標，並讓工程師明確瞭解這次要努力的方向。\n例如：不擅長溝通的工程師嘗試讓工程師做些溝通的工作。\n一對一交流：讓工程師有機會與主管進行一對一的交流，個人的關注可以讓工程師感受到被重視，而不只是公司的一個螺絲，用完就可以丟棄。\n稱讚：做得好的地方就值得被稱讚，尤其當老闆詢問專案做的很出色時，可以跟老闆強調是誰做的或誰想的，當然你的表揚要實際點，太多無謂的稱讚會讓工程師對於你的稱讚感到不屑。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E6%BF%80%E5%8B%B5%E5%92%8C%E9%BC%93%E5%8B%B5%E5%B7%A5%E7%A8%8B%E5%B8%AB/","summary":"前言\n要如何讓下屬發揮100%的能力甚至超過100%呢？很可惜我們沒有程式鼓勵員這個職位，只能自己下來鼓勵同仁來達到目標\n反饋：每一次的專案完成或進行中，適當的提供意見反饋，告知工程師如何進行可以做的更好，哪些點可能還需要再多做確認。\n責任：給予工程師適當的責任，可以透過言語的暗示，讓工程師感受到被認可與重視。\n例如：這個部分就交給你負責了，我相信你可以做到。\n目標：每次的案子都為工程師量身定制他的個人成長目標，並讓工程師明確瞭解這次要努力的方向。\n例如：不擅長溝通的工程師嘗試讓工程師做些溝通的工作。\n一對一交流：讓工程師有機會與主管進行一對一的交流，個人的關注可以讓工程師感受到被重視，而不只是公司的一個螺絲，用完就可以丟棄。\n稱讚：做得好的地方就值得被稱讚，尤其當老闆詢問專案做的很出色時，可以跟老闆強調是誰做的或誰想的，當然你的表揚要實際點，太多無謂的稱讚會讓工程師對於你的稱讚感到不屑。","title":"2023ITHelp 激勵和鼓勵工程師"},{"content":"前言\n一個高效的團隊可以加速工作流程，激發創意，提高生產力，並充分發揮每個成員的潛力。接下來將探討建立高效工作團隊的重要性以及一些關鍵策略。\n高效工作團隊通常具備的特徵\n多元化的觀點： 高效的團隊通常由具有多樣性背景和技能的成員組成。這種多元化可以帶來不同的觀點和解決問題的方法。\n適應力：高效的團隊比較容易有良好的適應力，遇到突發狀況比較靈機應變。\n協作能力：高效的團隊可以互相配合互相支援，達到一加一大於二。\n評估自己未來所需要建立的團隊\n我需要是有流暢的溝通管道，會願意自主提升競爭力，互相學習，良性競爭，知道自己所需要的團隊後，第一步依然是從自己開始做起再來逐步的實現目標，了解自己需要什麼後就可以列出來\n良好的溝通管道 分享互相學習的文化 成果導向 接下來就可以依據這幾點階段性的進行調整，來達到目的。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%BB%BA%E7%AB%8B%E9%AB%98%E6%95%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9C%98%E9%9A%8A/","summary":"前言\n一個高效的團隊可以加速工作流程，激發創意，提高生產力，並充分發揮每個成員的潛力。接下來將探討建立高效工作團隊的重要性以及一些關鍵策略。\n高效工作團隊通常具備的特徵\n多元化的觀點： 高效的團隊通常由具有多樣性背景和技能的成員組成。這種多元化可以帶來不同的觀點和解決問題的方法。\n適應力：高效的團隊比較容易有良好的適應力，遇到突發狀況比較靈機應變。\n協作能力：高效的團隊可以互相配合互相支援，達到一加一大於二。\n評估自己未來所需要建立的團隊\n我需要是有流暢的溝通管道，會願意自主提升競爭力，互相學習，良性競爭，知道自己所需要的團隊後，第一步依然是從自己開始做起再來逐步的實現目標，了解自己需要什麼後就可以列出來\n良好的溝通管道 分享互相學習的文化 成果導向 接下來就可以依據這幾點階段性的進行調整，來達到目的。","title":"2023ITHelp 建立高效的工作團隊"},{"content":"前言\n在現代快節奏的生活中，有效的時間管理和優先事項設定變得至關重要。不論是一位專業人士、學生還是企業家，精良的時間管理技巧可以幫助您充分發揮潛力，實現更多的目標，減少壓力並提高生活質量。本文將探討一些關鍵的策略和技巧，有助於個人效率的提升。\n使用時間管理工具：善用工具是可以有效提升效率的一件事情，對工具的要求就是簡單使用不要想用太多的功能，曾經花很多時間研究各式各樣的工具最後還是選擇使用google行事曆跟notion而已。\n學會說不：說不是一項重要的技能，可以幫助我們節省自己的時間。當已經有滿滿的行程時，學會拒絕額外的承諾，確保有足夠的時間處理重要工作。每次都答應他人的請求只會變成濫好人，不是所有人都會珍惜和感謝你的幫忙，超過自己的負擔就勇敢拒絕。\nNotion教育版 只要還有學校信箱進行驗證可以免費兌換教育版，強力推薦！！\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E6%99%82%E9%96%93%E7%AE%A1%E7%90%86%E5%92%8C%E5%84%AA%E5%85%88%E4%BA%8B%E9%A0%85%E8%A8%AD%E5%AE%9A/","summary":"前言\n在現代快節奏的生活中，有效的時間管理和優先事項設定變得至關重要。不論是一位專業人士、學生還是企業家，精良的時間管理技巧可以幫助您充分發揮潛力，實現更多的目標，減少壓力並提高生活質量。本文將探討一些關鍵的策略和技巧，有助於個人效率的提升。\n使用時間管理工具：善用工具是可以有效提升效率的一件事情，對工具的要求就是簡單使用不要想用太多的功能，曾經花很多時間研究各式各樣的工具最後還是選擇使用google行事曆跟notion而已。\n學會說不：說不是一項重要的技能，可以幫助我們節省自己的時間。當已經有滿滿的行程時，學會拒絕額外的承諾，確保有足夠的時間處理重要工作。每次都答應他人的請求只會變成濫好人，不是所有人都會珍惜和感謝你的幫忙，超過自己的負擔就勇敢拒絕。\nNotion教育版 只要還有學校信箱進行驗證可以免費兌換教育版，強力推薦！！","title":"2023ITHelp 時間管理和優先事項設定"},{"content":"前言\n每當遇到問題時，腦海裡就要立刻有兩三個方案，需求無時無刻都在變化，當變化的當下可以立刻找到最佳路徑去實現，你的價值就展現出來了，這是培養解決問題能力的關鍵之一。而現實生活中或職場上，決策每天都在發生，因為時程問題無法完成所有的項目，就需要下決策決定要捨棄哪些項目，必須在有限的資源中提高專案的完整度。因此培養這兩個能力也是很重要的。\n釐清問題：解決問題前首先要知道問題，我們就是個醫生，透過不斷的詢問，將問題不斷的收斂，接下來才有辦法思考如何解決問題。\n學習不同的解決流程：多瞭解不同的解決問題的流程，SWOT、、因果分析、、設計思考，多嘗試不同的思考流程，來找到適合自己的方法。\n資源最大化：盡可能爭取更多資源，不要浪費任何的資源，不管是時間預算或是人力。\n分析選擇：做決策時要分析各式的選擇中每個選項的好壞，不止要考慮短期的影響，也要考慮長期的影響。\n換工作時需要看的不只是薪水也要看到長期發展，會不會現在領到六萬的薪水，但因為工作內容無法學習新的技術，很容易被淘汰，長期下來其實會停滯在這個薪水甚至還沒辦法換工作\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%9F%B9%E9%A4%8A%E8%A7%A3%E6%B1%BA%E5%95%8F%E9%A1%8C%E5%92%8C%E6%B1%BA%E7%AD%96%E8%83%BD%E5%8A%9B/","summary":"前言\n每當遇到問題時，腦海裡就要立刻有兩三個方案，需求無時無刻都在變化，當變化的當下可以立刻找到最佳路徑去實現，你的價值就展現出來了，這是培養解決問題能力的關鍵之一。而現實生活中或職場上，決策每天都在發生，因為時程問題無法完成所有的項目，就需要下決策決定要捨棄哪些項目，必須在有限的資源中提高專案的完整度。因此培養這兩個能力也是很重要的。\n釐清問題：解決問題前首先要知道問題，我們就是個醫生，透過不斷的詢問，將問題不斷的收斂，接下來才有辦法思考如何解決問題。\n學習不同的解決流程：多瞭解不同的解決問題的流程，SWOT、、因果分析、、設計思考，多嘗試不同的思考流程，來找到適合自己的方法。\n資源最大化：盡可能爭取更多資源，不要浪費任何的資源，不管是時間預算或是人力。\n分析選擇：做決策時要分析各式的選擇中每個選項的好壞，不止要考慮短期的影響，也要考慮長期的影響。\n換工作時需要看的不只是薪水也要看到長期發展，會不會現在領到六萬的薪水，但因為工作內容無法學習新的技術，很容易被淘汰，長期下來其實會停滯在這個薪水甚至還沒辦法換工作","title":"2023ITHelp 培養解決問題和決策能力"},{"content":"前言\n在職場中，衝突是不可避免的，不管在哪個組織或團隊，都會出現不同的意見、想法，當發生衝突時，要如何妥善處理是相當重要的，因為會直接影響到工作環境的和諧與團隊的效率，當你可以解決衝突避免衝突時，就是提升自身價值的時候。\n中斷節奏：當雙方已經有些微的火藥味時，適時的中斷節奏會是很好的一個辦法。\n例如：曾經我的主管與其他主管在會議中開始有些微摩擦，當情況越來越不對勁的時候，可以透過疑問的方式將衝突中斷，避免會議氣氛惡化，例如：不好意思我打斷一下，剛剛有說到這個專案是希望解決xxx，那我的想法是xxx，不知道有沒有解決你們問題？\n透過放低身段詢問的方式，來化解要準備爆發的衝突或已經爆發的衝突。\n例如：當下屬為了技術爭論不休的時候立刻請兩位當事者暫停討論，並介入了解狀況與雙方的立場後，進行個別的面談協助說明另一方的立場與原因，讓當事者可以理解另一方，當中需要注意的是嚴禁偏頗某一方。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E8%A7%A3%E6%B1%BA%E8%A1%9D%E7%AA%81/","summary":"前言\n在職場中，衝突是不可避免的，不管在哪個組織或團隊，都會出現不同的意見、想法，當發生衝突時，要如何妥善處理是相當重要的，因為會直接影響到工作環境的和諧與團隊的效率，當你可以解決衝突避免衝突時，就是提升自身價值的時候。\n中斷節奏：當雙方已經有些微的火藥味時，適時的中斷節奏會是很好的一個辦法。\n例如：曾經我的主管與其他主管在會議中開始有些微摩擦，當情況越來越不對勁的時候，可以透過疑問的方式將衝突中斷，避免會議氣氛惡化，例如：不好意思我打斷一下，剛剛有說到這個專案是希望解決xxx，那我的想法是xxx，不知道有沒有解決你們問題？\n透過放低身段詢問的方式，來化解要準備爆發的衝突或已經爆發的衝突。\n例如：當下屬為了技術爭論不休的時候立刻請兩位當事者暫停討論，並介入了解狀況與雙方的立場後，進行個別的面談協助說明另一方的立場與原因，讓當事者可以理解另一方，當中需要注意的是嚴禁偏頗某一方。","title":"2023ITHelp 解決衝突"},{"content":"前言\n設想一下你當下屬時，你希望遇到什麼樣的主管，就用這種方式去審思你自己的管理模式。有效的向下管理不僅僅涉及到指導和監督，還需要建立積極的工作環境，激勵下屬參與和貢獻，團隊的成長就是證明你能力的關鍵，只有自己強已經不是身為主管的重點，重要是如何影響團隊，讓團隊成員跟上成長的步伐，不輕易放棄任何人，幫所有人找出屬於團隊的位置。\n溝通管道順暢：我會希望我與我的主管在溝通方面沒有任何隔閡，有任何問題都可反應，也不會用主管對下屬的方式進行施壓。\n解決所反映的問題：當我遇到問題與主管反應後，會希望主管能有所作為，而不是只是說說，敷衍了事。\n不搶功勞：不希望我得主管有問題時推給下屬，有功勞時卻攬在自己身上。\n願意承擔責任：我會希望我的主管會當我的靠山，真的發生事情時，主管會願意協助我解決問題，而非一副事不關己的態度。\n反向思考就是好的向下管理的方法。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%90%91%E4%B8%8B%E7%AE%A1%E7%90%86/","summary":"前言\n設想一下你當下屬時，你希望遇到什麼樣的主管，就用這種方式去審思你自己的管理模式。有效的向下管理不僅僅涉及到指導和監督，還需要建立積極的工作環境，激勵下屬參與和貢獻，團隊的成長就是證明你能力的關鍵，只有自己強已經不是身為主管的重點，重要是如何影響團隊，讓團隊成員跟上成長的步伐，不輕易放棄任何人，幫所有人找出屬於團隊的位置。\n溝通管道順暢：我會希望我與我的主管在溝通方面沒有任何隔閡，有任何問題都可反應，也不會用主管對下屬的方式進行施壓。\n解決所反映的問題：當我遇到問題與主管反應後，會希望主管能有所作為，而不是只是說說，敷衍了事。\n不搶功勞：不希望我得主管有問題時推給下屬，有功勞時卻攬在自己身上。\n願意承擔責任：我會希望我的主管會當我的靠山，真的發生事情時，主管會願意協助我解決問題，而非一副事不關己的態度。\n反向思考就是好的向下管理的方法。","title":"2023ITHelp 向下管理"},{"content":"前言\n水平溝通的目的是讓自己與其他同階層的主管配合更加順暢，並讓合作更有效率，難易度上水平溝通會是最難的，向上管理：老闆就是叫你做你能不做嗎？最壞也不用溝通了，就是做。向下管理：部門的團隊文化掌握在自己，相對好掌握。\n同步資訊：升上主管後發現公司很容易資訊不同步，時常會有參與的部門沒有接收到訊息，\n例如：在我接收到任何資訊時立刻與各部門同步，如果不知道與哪些部門相關，就通知所有部門，不需要擔心同步錯人，我們的目的是不要有人沒有被通知。\n多做不吃虧：各部門配合時，多詢問我怎麼做會讓你們比較好做事，善的循環從自身開始做起，每件事情都多出一點力，當真的遇到困難或難配合的部門，就可以收回多做的部分。也可以平衡自己的心態🥲\n尊重：雖然在哪裡都要尊重，但是在水平之間更容易有衝突，切記要寬以待人，嚴以律己，\n曾經開了一場會議，目的是希望部門配合上可以更加順暢的檢討會，但是會議內容卻讓對方認為是在批評對方做事，導致雙方吵了起來，沒有達到這場會議的目的。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E6%B0%B4%E5%B9%B3%E7%AE%A1%E7%90%86/","summary":"前言\n水平溝通的目的是讓自己與其他同階層的主管配合更加順暢，並讓合作更有效率，難易度上水平溝通會是最難的，向上管理：老闆就是叫你做你能不做嗎？最壞也不用溝通了，就是做。向下管理：部門的團隊文化掌握在自己，相對好掌握。\n同步資訊：升上主管後發現公司很容易資訊不同步，時常會有參與的部門沒有接收到訊息，\n例如：在我接收到任何資訊時立刻與各部門同步，如果不知道與哪些部門相關，就通知所有部門，不需要擔心同步錯人，我們的目的是不要有人沒有被通知。\n多做不吃虧：各部門配合時，多詢問我怎麼做會讓你們比較好做事，善的循環從自身開始做起，每件事情都多出一點力，當真的遇到困難或難配合的部門，就可以收回多做的部分。也可以平衡自己的心態🥲\n尊重：雖然在哪裡都要尊重，但是在水平之間更容易有衝突，切記要寬以待人，嚴以律己，\n曾經開了一場會議，目的是希望部門配合上可以更加順暢的檢討會，但是會議內容卻讓對方認為是在批評對方做事，導致雙方吵了起來，沒有達到這場會議的目的。","title":"2023ITHelp 水平管理"},{"content":"前言\n向上管理的能力對於個人和團隊的成功都相當的重要，本文將討論如何如何做好向上管理。\n首先多問不要怕被罵，到了管理階，難免會受到責備，因為你已經是公司的一個樑柱，請記住你的決策是有影響力的，影響的不單單只有你，而是你所帶領的整個團隊。多透過詢問的方式了解你的上層或是你的老闆需要的是什麼，儘早掌握老闆的喜好與做事風格。他對於公司的優先順序是什麼？這過程難免會誤解老闆的意思，但不要過於擔心，只有不會成長的人才會一直被罵。\n了解：了解老闆什麼情況下比較好溝通，透過email的方式或是聊天訊息或是當面溝通\n例如：我會比較喜歡當面溝通，聊天訊息或是email很難完整表達我的想法，長期觀察下來老闆在當面溝通時比較好交流。\n回報：進行每個決策時都可以針對此次專案，說明要如何執行，再詢問老闆意見，一方面可以讓老闆知道我做決定的原因，另一方面可以知道老闆對於這次專案的想法。\n換位思考：思考一件事情，如果是老闆的角色，會關心什麼事情。\n例如：與第三方廠商簽約的金額增加了，以老闆的角度會想知道前一期的費用是多少，這次的費用是哪個部分增加，為什麼增加，不要只拿著這期的帳單就請老闆簽名，這個小動作就是加分的關鍵。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86/","summary":"前言\n向上管理的能力對於個人和團隊的成功都相當的重要，本文將討論如何如何做好向上管理。\n首先多問不要怕被罵，到了管理階，難免會受到責備，因為你已經是公司的一個樑柱，請記住你的決策是有影響力的，影響的不單單只有你，而是你所帶領的整個團隊。多透過詢問的方式了解你的上層或是你的老闆需要的是什麼，儘早掌握老闆的喜好與做事風格。他對於公司的優先順序是什麼？這過程難免會誤解老闆的意思，但不要過於擔心，只有不會成長的人才會一直被罵。\n了解：了解老闆什麼情況下比較好溝通，透過email的方式或是聊天訊息或是當面溝通\n例如：我會比較喜歡當面溝通，聊天訊息或是email很難完整表達我的想法，長期觀察下來老闆在當面溝通時比較好交流。\n回報：進行每個決策時都可以針對此次專案，說明要如何執行，再詢問老闆意見，一方面可以讓老闆知道我做決定的原因，另一方面可以知道老闆對於這次專案的想法。\n換位思考：思考一件事情，如果是老闆的角色，會關心什麼事情。\n例如：與第三方廠商簽約的金額增加了，以老闆的角度會想知道前一期的費用是多少，這次的費用是哪個部分增加，為什麼增加，不要只拿著這期的帳單就請老闆簽名，這個小動作就是加分的關鍵。","title":"2023ITHelp 向上管理"},{"content":"前言\n在我們討論如何由工程師升至經理的職業轉變時，首要的步驟之一是制定一個明確的規劃。讓我們想像一下，在未來兩年內，要成為怎樣的經理以及需要解決的主要項目。這個規劃將是我們達成目標的道路地圖。\n明確的規劃目標\n首先，讓我們設想我們的經理角色。在這個角色中，我們將需要應對多重挑戰。第一個挑戰是有效的管理，無論是向下管理、水平管理、還是向上管理，都需要出色的溝通技巧。提升團隊效率將成為首要考量，因為這將直接影響到部門的績效。\n第二個挑戰是處理部門聲譽的問題。當我們的部門在每次改版或專案上都遇到問題時，其他部門對我們的信任就會受損。因此，我們需要制定策略，提高部門的聲譽，確保我們的團隊能夠提供可靠的解決方案。\n第三個挑戰是在技術領域的持續成長。身為技術部門主管，我們需要保持對技術的敏感度，即使在增加管理工作的情況下。這意味著我們需要不斷學習和跟進最新的技術趨勢，同時將這些知識應用到我們的部門中。\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E8%81%B7%E6%A5%AD%E7%9B%AE%E6%A8%99%E8%88%87%E7%99%BC%E5%B1%95%E8%A8%88%E5%8A%83/","summary":"前言\n在我們討論如何由工程師升至經理的職業轉變時，首要的步驟之一是制定一個明確的規劃。讓我們想像一下，在未來兩年內，要成為怎樣的經理以及需要解決的主要項目。這個規劃將是我們達成目標的道路地圖。\n明確的規劃目標\n首先，讓我們設想我們的經理角色。在這個角色中，我們將需要應對多重挑戰。第一個挑戰是有效的管理，無論是向下管理、水平管理、還是向上管理，都需要出色的溝通技巧。提升團隊效率將成為首要考量，因為這將直接影響到部門的績效。\n第二個挑戰是處理部門聲譽的問題。當我們的部門在每次改版或專案上都遇到問題時，其他部門對我們的信任就會受損。因此，我們需要制定策略，提高部門的聲譽，確保我們的團隊能夠提供可靠的解決方案。\n第三個挑戰是在技術領域的持續成長。身為技術部門主管，我們需要保持對技術的敏感度，即使在增加管理工作的情況下。這意味著我們需要不斷學習和跟進最新的技術趨勢，同時將這些知識應用到我們的部門中。","title":"2023ITHelp 職業目標與發展計劃"},{"content":"從工程師到經理的職業轉變 從工程師到經理，這不僅僅是一個職位的變換，更是一個角色的轉變，需要不同的技能和思維方式。一名優秀的工程師通常以其專業知識和技能為基石，但當你進入經理角色時，您將需要更多的領導力，溝通能力和策略思維。這種轉變可能是挑戰性的，但同時也是一個充滿機會的階段，可以讓您在組織中發揮更大的影響力。\n在接下來的三十天中，我們將探討各種關鍵主題，包括如何發展領導力技能，建立有效的團隊，掌握時間管理，解決挑戰和衝突，並在不斷變化的業務環境中保持敏銳的觸覺。將提供實用的建議，分享個人經驗故事，以幫助您實現從工程師到經理的平滑過渡。\n無論您是已經在這個轉變過程中，還是正在考慮未來的職業發展，本系列將為您提供有價值的信息和啟示。接下來的三十天，將跟你分享我是如何在兩年內從工程師晉升副理又晉升到經理\n我們將深入探討如何確定您的職業目標並制定發展計劃，這是成功轉型的關鍵第一步。敬請期待！\n","permalink":"http://localhost:1313/softskills/2023ithelp-%E5%BE%9E%E5%B7%A5%E7%A8%8B%E5%B8%AB%E5%88%B0%E7%B6%93%E7%90%86%E7%9A%84%E8%81%B7%E6%A5%AD%E8%BD%89%E8%AE%8A/","summary":"從工程師到經理的職業轉變 從工程師到經理，這不僅僅是一個職位的變換，更是一個角色的轉變，需要不同的技能和思維方式。一名優秀的工程師通常以其專業知識和技能為基石，但當你進入經理角色時，您將需要更多的領導力，溝通能力和策略思維。這種轉變可能是挑戰性的，但同時也是一個充滿機會的階段，可以讓您在組織中發揮更大的影響力。\n在接下來的三十天中，我們將探討各種關鍵主題，包括如何發展領導力技能，建立有效的團隊，掌握時間管理，解決挑戰和衝突，並在不斷變化的業務環境中保持敏銳的觸覺。將提供實用的建議，分享個人經驗故事，以幫助您實現從工程師到經理的平滑過渡。\n無論您是已經在這個轉變過程中，還是正在考慮未來的職業發展，本系列將為您提供有價值的信息和啟示。接下來的三十天，將跟你分享我是如何在兩年內從工程師晉升副理又晉升到經理\n我們將深入探討如何確定您的職業目標並制定發展計劃，這是成功轉型的關鍵第一步。敬請期待！","title":"2023ITHelp 從工程師到經理的職業轉變"},{"content":"三棵樹 flutter共有三個核心\nwidget tree 在flutter很常看到一層包一層，MaterialApp、Scaffold這類組件都是widget tree，我們通常只會對到這層。\nelement tree 會將資料儲存在記憶體，並決定要不要重新繪製UI\nrender tree 是由element tree控制，當element tree決定有必要修改，就會透過render tree進行UI修改\n","permalink":"http://localhost:1313/flutter/three-tree/","summary":"三棵樹 flutter共有三個核心\nwidget tree 在flutter很常看到一層包一層，MaterialApp、Scaffold這類組件都是widget tree，我們通常只會對到這層。\nelement tree 會將資料儲存在記憶體，並決定要不要重新繪製UI\nrender tree 是由element tree控制，當element tree決定有必要修改，就會透過render tree進行UI修改","title":"Three Tree"},{"content":"如何鎖定裝置的方向 先到main.dart檔案找到最初的進入點main()要執行runApp時，先執行\nWidgetsFlutterBinding.ensureInitialized(); 確定每次執行都要初始化 SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp,]) 選擇我們接受的方向 所在的函示庫記得引入 import \u0026lsquo;package:flutter/services.dart\u0026rsquo;;\nvoid main() { WidgetsFlutterBinding.ensureInitialized(); SystemChrome.setPreferredOrientations([ DeviceOrientation.portraitUp, ]).then((value) =\u0026gt; { runApp(MaterialApp( home: const Expenses(), )) }); } ","permalink":"http://localhost:1313/flutter/%E5%A6%82%E4%BD%95%E5%9B%BA%E5%AE%9A%E8%A8%AD%E5%82%99%E6%96%B9%E5%90%91/","summary":"如何鎖定裝置的方向 先到main.dart檔案找到最初的進入點main()要執行runApp時，先執行\nWidgetsFlutterBinding.ensureInitialized(); 確定每次執行都要初始化 SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp,]) 選擇我們接受的方向 所在的函示庫記得引入 import \u0026lsquo;package:flutter/services.dart\u0026rsquo;;\nvoid main() { WidgetsFlutterBinding.ensureInitialized(); SystemChrome.setPreferredOrientations([ DeviceOrientation.portraitUp, ]).then((value) =\u0026gt; { runApp(MaterialApp( home: const Expenses(), )) }); } ","title":"如何固定設備方向"},{"content":"資料庫架構設計 架構演變 讀寫分離 當遇到資料庫瓶頸時，最簡單的做法是將資料庫做主從架構 主資料庫只有做寫入並同步資料到其他從資料庫，被同步的資料庫可以是n個只做讀取 垂直分庫 資料還是持續增長後，就到了要做垂直分庫的架構了，垂直分庫的意思可以想像成將同一個資料表內的資料欄位做整理，分成多個資料庫，也就可以將不同資料庫放在不同機器上。 資料庫分成使用者資料庫、訂單資料庫、商品資料庫\n水平分庫 資料量再更大量，最後的解決方案就是水平分庫，會將相同的資料表分成多個表 table01、table02、table03\nSharding中介軟體 要做到水平分庫會建議使用已經發展成熟的Sharding中介軟體\nSharding架構 有區分成兩種\nPorxy架構 應用集成架構 ","permalink":"http://localhost:1313/posts/%E8%B3%87%E6%96%99%E5%BA%AB%E5%88%86%E8%A1%A8/","summary":"資料庫架構設計 架構演變 讀寫分離 當遇到資料庫瓶頸時，最簡單的做法是將資料庫做主從架構 主資料庫只有做寫入並同步資料到其他從資料庫，被同步的資料庫可以是n個只做讀取 垂直分庫 資料還是持續增長後，就到了要做垂直分庫的架構了，垂直分庫的意思可以想像成將同一個資料表內的資料欄位做整理，分成多個資料庫，也就可以將不同資料庫放在不同機器上。 資料庫分成使用者資料庫、訂單資料庫、商品資料庫\n水平分庫 資料量再更大量，最後的解決方案就是水平分庫，會將相同的資料表分成多個表 table01、table02、table03\nSharding中介軟體 要做到水平分庫會建議使用已經發展成熟的Sharding中介軟體\nSharding架構 有區分成兩種\nPorxy架構 應用集成架構 ","title":"資料庫分表"},{"content":"快速介紹flutter安裝的函式庫 intl 轉成指定地區的日期格式\nflutter pub add intl\nuuid 建立guid\nflutter pub add uuid\ntransparent_image 當圖還沒有載入時可以有透明背景圖使用\nflutter pub add transparent_image\nriverpod 是一個狀態管理的工具，當開始寫flutter就會遇到跟現在流行的框架vue/react一樣的問題，當我要傳遞資料時要一直往子層傳參數，才能將資料傳進去，這時riverpod就是來解決這個問題的 另一個社群討論度高的是Getx。\nflutter pub add riverpod\n要在需要的區塊上加上ProviderScope，下列範例就是所有區塊都要可以使用 void main() { runApp(const ProviderScope( child: MyApp(), )); } 新增一個檔案並建立供應方 import \u0026#39;package:flutter_riverpod/flutter_riverpod.dart\u0026#39;; final demoProvider = Provider((ref) { return false; }); = \u0026amp; ConsumerWidget StatelessWidget改成ConsumerWidget\nStatefulWidget改成ConsumerStatefulWidget\n建立接收方 //在要使用資料的地方使用下列 //當資料不會改變時可以使用read來取代watch，但官方建議一律使用watch，以免當資料異動時，沒有修改到 final demo = ref.watch(demoProvider); //接下來即可使用demo來做後續事情 http 進行restful api，透過這個套件可以發送請求到api並接收回傳\nflutter pub add http\nimage_picker 使用系統得相機功能，在ios中記得查看文件檔，將key放入文件所說明的plist檔案中\nflutter pub add image_picker\nlocation 取得使用者當下位置座標\nflutter pub add location\nGoogle Maps for Flutter 根據官方文件，安著需要設定minSdkVersion與key，設定完成後要記得重啟模擬器，才不會遇到錯誤\nflutter pub add google_maps_flutter\npath_provider 可以快速的找到平常文件常用得路徑\nflutter pub add path_provider\npath 簡化路徑處理\nflutter pub add path\nsqflite 可以使用sqlite\nflutter pub add sqflite\n","permalink":"http://localhost:1313/flutter/pub/","summary":"快速介紹flutter安裝的函式庫 intl 轉成指定地區的日期格式\nflutter pub add intl\nuuid 建立guid\nflutter pub add uuid\ntransparent_image 當圖還沒有載入時可以有透明背景圖使用\nflutter pub add transparent_image\nriverpod 是一個狀態管理的工具，當開始寫flutter就會遇到跟現在流行的框架vue/react一樣的問題，當我要傳遞資料時要一直往子層傳參數，才能將資料傳進去，這時riverpod就是來解決這個問題的 另一個社群討論度高的是Getx。\nflutter pub add riverpod\n要在需要的區塊上加上ProviderScope，下列範例就是所有區塊都要可以使用 void main() { runApp(const ProviderScope( child: MyApp(), )); } 新增一個檔案並建立供應方 import \u0026#39;package:flutter_riverpod/flutter_riverpod.dart\u0026#39;; final demoProvider = Provider((ref) { return false; }); = \u0026amp; ConsumerWidget StatelessWidget改成ConsumerWidget\nStatefulWidget改成ConsumerStatefulWidget\n建立接收方 //在要使用資料的地方使用下列 //當資料不會改變時可以使用read來取代watch，但官方建議一律使用watch，以免當資料異動時，沒有修改到 final demo = ref.watch(demoProvider); //接下來即可使用demo來做後續事情 http 進行restful api，透過這個套件可以發送請求到api並接收回傳\nflutter pub add http\nimage_picker 使用系統得相機功能，在ios中記得查看文件檔，將key放入文件所說明的plist檔案中\nflutter pub add image_picker","title":"Pub"},{"content":"佈局的屬性 Column 由上至下的排序\nRow 由左至右的排序\nExpanded 只能使用在繼承Flex以下的Widget，常使用在Cloumn或row的子項\n因為有些widget不會限制長寬，要有expanded來將最大值限制在手機區塊內\nListView 使用ListView是可以有滾動效果 可以透過builder提升效能 使用方法為\nListView.builder(item: list.length, itemBuilder: (ctx,index){list[index].title}) Spacer 可以在任何row,colume使用 佔用剩餘所有空間的意思\nTextField 輸入框\n要記得關閉\nDropdownButton 下拉式選單\nDismissable key參數必要，才能確定要滑動刪除哪筆資料 也可以分為向左滑動與向右滑動，執行不同功能 滑動刪除效果\nSnackbar 會在螢幕下面調出一個訊息框 在Scaffold階層底下可以使用\nScaffoldMessenger.of(context).showSnackBar( const SnackBar( duration: Duration(seconds: 3), content: Text(\u0026#39;Expense deleted\u0026#39;), ), ); InkWell 可以讓沒有事件的元件增加點擊事件之類的功能 與GestureDetector的差別在於 GestureDetector提供更多的點擊事件，InkWell提供點擊特效\n兩者差異出處\nStack 類似Column與Row，但是可以讓所有子元件重疊在一起\nSwitchListTile 有大標題與子標題的開關\nDrawer 側邊欄，可以在裡面放Column就可以實現側邊欄的菜單\nWillPopScope 當用戶離開用任何方式離開當下頁面就會觸發，不管是實體按鈕或是虛擬按鈕 onWillPop:true 允許返回false不允許返回\nForm 有額外的驗證功能，並顯示在畫面\n在form裡面要輸入框時要用TextFormField取代TextField\n只要在Form裏面，要使用的組件基本上都會有form關鍵字\nDismissible 新增滑動移除的功能，需要增加key值才能知道要動作的是哪一個項目\n後續慢慢補上\n","permalink":"http://localhost:1313/flutter/widget/","summary":"佈局的屬性 Column 由上至下的排序\nRow 由左至右的排序\nExpanded 只能使用在繼承Flex以下的Widget，常使用在Cloumn或row的子項\n因為有些widget不會限制長寬，要有expanded來將最大值限制在手機區塊內\nListView 使用ListView是可以有滾動效果 可以透過builder提升效能 使用方法為\nListView.builder(item: list.length, itemBuilder: (ctx,index){list[index].title}) Spacer 可以在任何row,colume使用 佔用剩餘所有空間的意思\nTextField 輸入框\n要記得關閉\nDropdownButton 下拉式選單\nDismissable key參數必要，才能確定要滑動刪除哪筆資料 也可以分為向左滑動與向右滑動，執行不同功能 滑動刪除效果\nSnackbar 會在螢幕下面調出一個訊息框 在Scaffold階層底下可以使用\nScaffoldMessenger.of(context).showSnackBar( const SnackBar( duration: Duration(seconds: 3), content: Text(\u0026#39;Expense deleted\u0026#39;), ), ); InkWell 可以讓沒有事件的元件增加點擊事件之類的功能 與GestureDetector的差別在於 GestureDetector提供更多的點擊事件，InkWell提供點擊特效\n兩者差異出處\nStack 類似Column與Row，但是可以讓所有子元件重疊在一起\nSwitchListTile 有大標題與子標題的開關\nDrawer 側邊欄，可以在裡面放Column就可以實現側邊欄的菜單\nWillPopScope 當用戶離開用任何方式離開當下頁面就會觸發，不管是實體按鈕或是虛擬按鈕 onWillPop:true 允許返回false不允許返回\nForm 有額外的驗證功能，並顯示在畫面\n在form裡面要輸入框時要用TextFormField取代TextField\n只要在Form裏面，要使用的組件基本上都會有form關鍵字\nDismissible 新增滑動移除的功能，需要增加key值才能知道要動作的是哪一個項目\n後續慢慢補上","title":"Widget"},{"content":"軟實力第一篇 ","permalink":"http://localhost:1313/softskills/fire/","summary":"軟實力第一篇 ","title":"Fire"},{"content":"Ha Today is a good day ","permalink":"http://localhost:1313/posts/first/","summary":"Ha Today is a good day ","title":"First"},{"content":"目的 在windows系統上想執行排程有兩個選擇\n使用windows工作排程器執行exe檔 透過Hangfire進行排程管理 此次教學說明如何使用Hangfire執行排程\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Hangfire Hangfire.InMemory 編輯Program.cs檔 using Hangfire; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊hangfire並且使用記憶體保存排程， //預設所下載的HangFire套件可以使用sqlserver，可透過config.UseSqlServerStorage();，但需要設定 builder.Services.AddHangfire(config =\u0026gt; { config.UseInMemoryStorage(); }); //註冊hangfire要使用的伺服器，伺服器就是上面所寫的使用記憶體當伺服器 builder.Services.AddHangfireServer(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); //使用hangfire內建的儀表板 app.UseHangfireDashboard(); app.MapControllers(); app.Run(); 編輯WeatherForecastController.cs類別檔 //記得using Hangfire; [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //單次立即執行 BackgroundJob.Enqueue(() =\u0026gt; Console.WriteLine(\u0026#34;單次!\u0026#34;)); //單次10秒後執行 BackgroundJob.Schedule(() =\u0026gt; Console.WriteLine(\u0026#34;10秒後執行!\u0026#34;), TimeSpan.FromSeconds(10)); //重複執行，預設為每天00:00啟動 RecurringJob.AddOrUpdate(() =\u0026gt; Console.WriteLine(\u0026#34;重複執行！\u0026#34;), Cron.Daily); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } 執行結果 F5執行後，依照下列步驟操作，並確認結果 接下來到hangfire儀表板查看執行狀態\n預設的網址為https://domain/hangfire 我的swagger網址為 https://localhost:7198/swagger/index.html 所以下方為hangfire預設路徑 https://localhost:7198/hangfire\n就可以看到Hangfire的畫面了，接著點擊上方工作就可以看到所執行的排程，如需看重複作業則點選定期工作 後記 任務排程的套件還有另外兩個Coravel與Quart.Net都可以參考看看\n參考 Hangfire官網\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-hangfire%E7%AF%84%E4%BE%8B/","summary":"目的 在windows系統上想執行排程有兩個選擇\n使用windows工作排程器執行exe檔 透過Hangfire進行排程管理 此次教學說明如何使用Hangfire執行排程\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Hangfire Hangfire.InMemory 編輯Program.cs檔 using Hangfire; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊hangfire並且使用記憶體保存排程， //預設所下載的HangFire套件可以使用sqlserver，可透過config.UseSqlServerStorage();，但需要設定 builder.Services.AddHangfire(config =\u0026gt; { config.UseInMemoryStorage(); }); //註冊hangfire要使用的伺服器，伺服器就是上面所寫的使用記憶體當伺服器 builder.Services.AddHangfireServer(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); //使用hangfire內建的儀表板 app.UseHangfireDashboard(); app.","title":"dotnet6 Hangfire範例"},{"content":"目的 面試的時候被問到要如何做包含外部api的單元測試問題，稍微查一下其實很簡單，怎麼當下答不出來呢? 主要有兩種方式，一種為.net core 2.1以後有提供IHttpClientFactory的介面可以使用。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立資料夾 編輯Program.cs檔案 註冊AddHttpClient。\nbuilder.Services.AddHttpClient(); 新增一個類別檔 加入前 加入後 建構子注入 將註冊的httpclient透過建構子注入\nreadonly IHttpClientFactory _httpClientFactory;\rpublic CallAPIServices(IHttpClientFactory httpClientFactory) {\r_httpClientFactory = httpClientFactory;\r} 加入前 加入後 新增方法 新增一個會去發外部請求的方法，模擬當有包含第三方api時如何測試\npublic async Task\u0026lt;string\u0026gt; Get() {\rvar client = _httpClientFactory.CreateClient();\rvar response = await client.GetAsync(\u0026#34;https://example.com\u0026#34;);\rif (response.IsSuccessStatusCode) {\rvar responseString = await response.Content.ReadAsStringAsync();\rreturn responseString;\r}\rreturn \u0026#34;\u0026#34;;\r} 新增測試專案 對方案點選右鍵\u0026gt;加入\u0026gt;新增專案\n設定新的專案 替測試專案命名，建議命名規則以.Tests做結尾 其他資訊 專案架構需要與要測試的專案相同 加入參考 將要測試的專案加入測試專案\n對CallAPIServices.Tests點選右鍵\u0026gt;加入\u0026gt;專案參考\nNuGet加入套件 透過NuGet安裝Moq套件至測試專案 新增對應資料夾與測試檔案 新增檔案，檔名需要與要測試的檔案一致，並加上Tests 新增程式碼 在新增的檔案內新增一個方法並寫入程式碼，一開始會看到許多紅色波浪，是因為沒有加入參考\n//定義這個方法是不需要傳入參數的單元測試，另一種為[Theory]，詳細說明可看相關參考5 [Fact] //命名規則 =\u0026gt; 類別名稱_方法名稱_要測試的方法行為_回傳狀態 public async Task CallAPIServices_Get_HttpClient_Success() { //模擬出一個IHttpClientFactory的假物件 var mockFactory = new Mock\u0026lt;IHttpClientFactory\u0026gt;(); //產生http回傳的實例 HttpResponseMessage result = new HttpResponseMessage() { StatusCode = HttpStatusCode.OK, Content = new StringContent(\u0026#34;{\u0026#39;account\u0026#39;:\u0026#39;bill\u0026#39;,\u0026#39;age\u0026#39;:18}\u0026#34;) }; //模擬出一個http處理程序的基本類型實例的假物件 var mockHttpMessageHandler = new Mock\u0026lt;HttpMessageHandler\u0026gt;(); //模擬http發出請求後所做的一連串事情，最後並回傳結果 //protected =\u0026gt; 發出請求的方法SendAsync是一個protected存取修飾詞，不能直接存取，所以告訴moq請幫忙執行protected方法，詳細說明可看參考6 //Setup =\u0026gt; 設定此執行動作為SendAsync方法，並需要兩個傳入參數，HttpRequestMessage與CancellationToken //ItExpr.IsAny =\u0026gt; 請moq協助傳入一個參數為HttpRequestMessage與CancellationToken的假參數，另一種為It.IsAny是非protected方法使用 //ReturnsAsync =\u0026gt; 回傳非同步的值 mockHttpMessageHandler.Protected() .Setup\u0026lt;Task\u0026lt;HttpResponseMessage\u0026gt;\u0026gt;(\u0026#34;SendAsync\u0026#34;, ItExpr.IsAny\u0026lt;HttpRequestMessage\u0026gt;(), ItExpr.IsAny\u0026lt;CancellationToken\u0026gt;()) .ReturnsAsync(result); //將製作好的假請求與回傳給HttpClient var client = new HttpClient(mockHttpMessageHandler.Object); //模擬實際請求，並接收到我們所製作的假物件 mockFactory.Setup(_ =\u0026gt; _.CreateClient(It.IsAny\u0026lt;string\u0026gt;())).Returns(client); //將製作好的完整請求流程給我們在使用的方法 var services = new HttpclientExample.Services.CallAPIServices(mockFactory.Object); //執行要測試的方法 var response = await services.Get(); //回傳值不能為null Assert.NotNull(response); //回傳值必須一致 Assert.Equal(\u0026#34;{\u0026#39;account\u0026#39;:\u0026#39;bill\u0026#39;,\u0026#39;age\u0026#39;:18}\u0026#34;, response); } 加入前 加入後 執行測試 點右鍵執行測試，最後結果會如左下角顯示成功 相關參考 單元測試好的做法 為什麼要使用IHttpClientFactory moq套件介紹 單元測試介紹 Fact跟Theory差別 存取修飾詞\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-httpclient%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E7%AF%84%E4%BE%8B/","summary":"目的 面試的時候被問到要如何做包含外部api的單元測試問題，稍微查一下其實很簡單，怎麼當下答不出來呢? 主要有兩種方式，一種為.net core 2.1以後有提供IHttpClientFactory的介面可以使用。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立資料夾 編輯Program.cs檔案 註冊AddHttpClient。\nbuilder.Services.AddHttpClient(); 新增一個類別檔 加入前 加入後 建構子注入 將註冊的httpclient透過建構子注入\nreadonly IHttpClientFactory _httpClientFactory;\rpublic CallAPIServices(IHttpClientFactory httpClientFactory) {\r_httpClientFactory = httpClientFactory;\r} 加入前 加入後 新增方法 新增一個會去發外部請求的方法，模擬當有包含第三方api時如何測試\npublic async Task\u0026lt;string\u0026gt; Get() {\rvar client = _httpClientFactory.CreateClient();\rvar response = await client.GetAsync(\u0026#34;https://example.com\u0026#34;);\rif (response.IsSuccessStatusCode) {\rvar responseString = await response.Content.ReadAsStringAsync();\rreturn responseString;\r}\rreturn \u0026#34;\u0026#34;;\r} 新增測試專案 對方案點選右鍵\u0026gt;加入\u0026gt;新增專案\n設定新的專案 替測試專案命名，建議命名規則以.Tests做結尾 其他資訊 專案架構需要與要測試的專案相同 加入參考 將要測試的專案加入測試專案","title":"dotnet6 HttpClient單元測試範例"},{"content":"目的 進行單元測試時，可以隔絕依賴的項目。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成MoqExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector Moq 針對MoqExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增WeatherForecastControllerTests.cs類別檔 刪除預設的類別檔(Class1.cs)，並在MoqExample.Tests專案新增對應資料夾，與類別檔並加結尾Tests。 編輯WeatherForecastControllerTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 這次要測試的是controller，有注入Ilogger，如何將Ilogger隔開的關鍵就是使用Moq這個套件 using Microsoft.Extensions.Logging; using Moq; using MoqExample.Controllers; using Xunit; namespace MoqExample.Tests.Controllers { public class WeatherForecastControllerTests { [Fact] public void Get() { //Arrange //透過mock將外界的介面包起來 var MockLogger = new Mock\u0026lt;ILogger\u0026lt;WeatherForecastController\u0026gt;\u0026gt;(); //當成物件傳入controller，代替實際的介面 var Controllers = new WeatherForecastController(MockLogger.Object); //Act //執行要測試的函式 var Results = Controllers.Get(); //Assert //確認結果不為null Assert.NotNull(Results); //確認結果數量等於5 Assert.Equal(5, Results.Count()); } } } 執行結果 點選測試\u0026gt;執行所有測試\n下方視窗就會顯示成功或失敗 參考 Moq-Quickstart\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-moq%E7%AF%84%E4%BE%8B/","summary":"目的 進行單元測試時，可以隔絕依賴的項目。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成MoqExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector Moq 針對MoqExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增WeatherForecastControllerTests.cs類別檔 刪除預設的類別檔(Class1.cs)，並在MoqExample.Tests專案新增對應資料夾，與類別檔並加結尾Tests。 編輯WeatherForecastControllerTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 這次要測試的是controller，有注入Ilogger，如何將Ilogger隔開的關鍵就是使用Moq這個套件 using Microsoft.Extensions.Logging; using Moq; using MoqExample.Controllers; using Xunit; namespace MoqExample.Tests.Controllers { public class WeatherForecastControllerTests { [Fact] public void Get() { //Arrange //透過mock將外界的介面包起來 var MockLogger = new Mock\u0026lt;ILogger\u0026lt;WeatherForecastController\u0026gt;\u0026gt;(); //當成物件傳入controller，代替實際的介面 var Controllers = new WeatherForecastController(MockLogger.Object); //Act //執行要測試的函式 var Results = Controllers.Get(); //Assert //確認結果不為null Assert.","title":"dotnet6 Moq範例"},{"content":"目的 在寫nlog.config檔案時覺得怎麼有點複雜，我只是需要簡單的設定檔就好了，最後決定透過appsetting來做設定 將log文件採用非同步寫入，可大幅提升效能 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 4.NuGet加入套件 NLog NLog.Web.AspNetCore 編輯Program.cs檔 using NLog; using NLog.Web; //初始化NLog var logger = LogManager.Setup() //載入Configuration並且讀取appsetting來使用 .LoadConfigurationFromAppSettings() .GetCurrentClassLogger(); try { logger.Debug(\u0026#34;init main\u0026#34;); var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Logging.ClearProviders(); builder.Host.UseNLog(); builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //以下省略 編輯appsetting.json 設定NLog，包含\nthrowConfigExceptions:設定檔錯誤時會跳exception 使用非同步方式寫入檔案 targets:設定輸出的格式，例如txt檔案或是Console顯示 rules:什麼情況要做什麼動作，例如log名稱為Microsoft.AspNetCore最小等級是warn時寫到Console ILogger NLog Level 0 Trace Trace Level 1 Debug Debug Level 2 Information Info Level 3 Warning Warn Level 4 Error Error Level 5 Critical Fatal Level 6 None NLog沒有 { \u0026#34;NLog\u0026#34;: { \u0026#34;throwConfigExceptions\u0026#34;: true, \u0026#34;targets\u0026#34;: { \u0026#34;async\u0026#34;: true, \u0026#34;logfile\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;File\u0026#34;, \u0026#34;fileName\u0026#34;: \u0026#34;c:/temp/nlog-${shortdate}.txt\u0026#34; }, \u0026#34;logconsole\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Console\u0026#34; } }, \u0026#34;rules\u0026#34;: [ { \u0026#34;logger\u0026#34;: \u0026#34;Microsoft.AspNetCore\u0026#34;, \u0026#34;minLevel\u0026#34;: \u0026#34;Warn\u0026#34;, \u0026#34;writeTo\u0026#34;: \u0026#34;logconsole\u0026#34; }, { \u0026#34;logger\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;minLevel\u0026#34;: \u0026#34;Info\u0026#34;, \u0026#34;writeTo\u0026#34;: \u0026#34;logfile\u0026#34; } ] } } 編輯WeatherForecastController.cs類別檔 [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //新增一個類型 var StudentObject = new Student() { Id = 4, Name = \u0026#34;Bill\u0026#34;, Age = 20 }; //新增一個匿名類型 var position = new { Latitude = 25, Longitude = 134 }; //寫log等級為error的log，當需要紀錄物件時需要透過{@該物件}來表示 _logger.LogError(\u0026#34;Error Value: {@StudentObject}\u0026#34;, StudentObject); _logger.LogError(\u0026#34;Error Value: {@position}\u0026#34;, position); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } public class Student { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果 執行後查看log檔案，這次寫到C:\\temp底下 第一個紅框處顯示物件內容 第二個紅框處顯示使用Get請求呼叫了WeatherForecast回傳狀態碼200用了54.3ms的時間 結論 最後其實會發現Serilog相對來說比較容易使用，也建議使用serilog\n參考 黑暗執行緒 中文輸出為unicode問題 target參數中文解說 非同步使用方式與縮寫\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-nlog%E9%80%B2%E9%9A%8E%E7%AF%84%E4%BE%8B/","summary":"目的 在寫nlog.config檔案時覺得怎麼有點複雜，我只是需要簡單的設定檔就好了，最後決定透過appsetting來做設定 將log文件採用非同步寫入，可大幅提升效能 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 4.NuGet加入套件 NLog NLog.Web.AspNetCore 編輯Program.cs檔 using NLog; using NLog.Web; //初始化NLog var logger = LogManager.Setup() //載入Configuration並且讀取appsetting來使用 .LoadConfigurationFromAppSettings() .GetCurrentClassLogger(); try { logger.Debug(\u0026#34;init main\u0026#34;); var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Logging.ClearProviders(); builder.Host.UseNLog(); builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //以下省略 編輯appsetting.json 設定NLog，包含\nthrowConfigExceptions:設定檔錯誤時會跳exception 使用非同步方式寫入檔案 targets:設定輸出的格式，例如txt檔案或是Console顯示 rules:什麼情況要做什麼動作，例如log名稱為Microsoft.AspNetCore最小等級是warn時寫到Console ILogger NLog Level 0 Trace Trace Level 1 Debug Debug Level 2 Information Info Level 3 Warning Warn Level 4 Error Error Level 5 Critical Fatal Level 6 None NLog沒有 { \u0026#34;NLog\u0026#34;: { \u0026#34;throwConfigExceptions\u0026#34;: true, \u0026#34;targets\u0026#34;: { \u0026#34;async\u0026#34;: true, \u0026#34;logfile\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;File\u0026#34;, \u0026#34;fileName\u0026#34;: \u0026#34;c:/temp/nlog-${shortdate}.","title":"dotnet6 NLog進階範例"},{"content":"目的 單元測試\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成xUnitExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector 新增Calculator.cs類別檔 在xUnitExample專案新增Calculator.cs類別檔 新增一個簡單的加法函式\npublic static class Calculator { public static double Add(int a, int b) { return a + b; } } 針對xUnitExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增CalculatorTests.cs類別檔 刪除預設的類別檔(Class1.cs)，建立對應的資料夾以及類別檔案，並在結尾加上Tests 編輯CalculatorTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 public class CalculatorTests { //告訴編譯器要執行的測試方法 [Fact] public void Add_() { //Arrange double Expected = 20; //Act var Actual = Calculator.Add(5, 15); //Assert Assert.Equal(Expected, Actual); } } 執行結果 點選測試\u0026gt;執行所有測試\n下方視窗就會顯示成功或失敗 後記 單元測試有另外兩種NUnit與mstest，基本上大同小異，並無太大的區別。\n參考 xUnit官網 該用什麼Packages\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-xunit%E7%AF%84%E4%BE%8B/","summary":"目的 單元測試\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 建立新的類別庫 進行命名時通常會與要測試的專案同名並加上結尾.Tests，以此範例就會變成xUnitExample.Tests NuGet加入套件 針對xUnitExample.Tests加入相關套件\nxunit xunit.runner.visualstudio Microsoft.NET.Test.Sdk coverlet.collector 新增Calculator.cs類別檔 在xUnitExample專案新增Calculator.cs類別檔 新增一個簡單的加法函式\npublic static class Calculator { public static double Add(int a, int b) { return a + b; } } 針對xUnitExample.Tests類別庫加入參考 引用要測試的專案，才能將測試與實際專案切分開來 新增CalculatorTests.cs類別檔 刪除預設的類別檔(Class1.cs)，建立對應的資料夾以及類別檔案，並在結尾加上Tests 編輯CalculatorTests.cs類別檔 測試都會分三個階段\nArrange：準備階段，包含初始化相關資料 Act：執行測試方法後所取得的結果 Assert：驗證Act取得的結果是否符合預期結果 public class CalculatorTests { //告訴編譯器要執行的測試方法 [Fact] public void Add_() { //Arrange double Expected = 20; //Act var Actual = Calculator.Add(5, 15); //Assert Assert.","title":"dotnet6 xUnit範例"},{"content":"目的 在webapi專案下使用NLog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 NLog NLog.Web.AspNetCore 新增nlog.config檔案 在根目錄新增nlog.config檔案 nlog.config寫入程式 在nlog.config寫入官方範例\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt;\r\u0026lt;nlog xmlns=\u0026#34;http://www.nlog-project.org/schemas/NLog.xsd\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rautoReload=\u0026#34;true\u0026#34;\rinternalLogLevel=\u0026#34;Info\u0026#34;\rinternalLogFile=\u0026#34;c:\\temp\\internal-nlog-AspNetCore.txt\u0026#34;\u0026gt;\r\u0026lt;!-- enable asp.net core layout renderers --\u0026gt;\r\u0026lt;extensions\u0026gt;\r\u0026lt;add assembly=\u0026#34;NLog.Web.AspNetCore\u0026#34;/\u0026gt;\r\u0026lt;/extensions\u0026gt;\r\u0026lt;!-- the targets to write to --\u0026gt;\r\u0026lt;targets\u0026gt;\r\u0026lt;!-- File Target for all log messages with basic details --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;allfile\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-all-${shortdate}.log\u0026#34;\rlayout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}\u0026#34; /\u0026gt;\r\u0026lt;!-- File Target for own log messages with extra web details using some ASP.NET core renderers --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;ownFile-web\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-own-${shortdate}.log\u0026#34;\rlayout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}|url: ${aspnet-request-url}|action: ${aspnet-mvc-action}|${callsite}\u0026#34; /\u0026gt;\r\u0026lt;!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;Console\u0026#34; name=\u0026#34;lifetimeConsole\u0026#34; layout=\u0026#34;${MicrosoftConsoleLayout}\u0026#34; /\u0026gt;\r\u0026lt;/targets\u0026gt;\r\u0026lt;!-- rules to map from logger name to target --\u0026gt;\r\u0026lt;rules\u0026gt;\r\u0026lt;!--All logs, including from Microsoft--\u0026gt;\r\u0026lt;logger name=\u0026#34;*\u0026#34; minlevel=\u0026#34;Trace\u0026#34; writeTo=\u0026#34;allfile\u0026#34; /\u0026gt;\r\u0026lt;!--Output hosting lifetime messages to console target for faster startup detection --\u0026gt;\r\u0026lt;logger name=\u0026#34;Microsoft.Hosting.Lifetime\u0026#34; minlevel=\u0026#34;Info\u0026#34; writeTo=\u0026#34;lifetimeConsole, ownFile-web\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt;\r\u0026lt;!--Skip non-critical Microsoft logs and so log only own logs (BlackHole) --\u0026gt;\r\u0026lt;logger name=\u0026#34;Microsoft.*\u0026#34; maxlevel=\u0026#34;Info\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt;\r\u0026lt;logger name=\u0026#34;System.Net.Http.*\u0026#34; maxlevel=\u0026#34;Info\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt;\r\u0026lt;logger name=\u0026#34;*\u0026#34; minlevel=\u0026#34;Trace\u0026#34; writeTo=\u0026#34;ownFile-web\u0026#34; /\u0026gt;\r\u0026lt;/rules\u0026gt;\r\u0026lt;/nlog\u0026gt; 只擷取部分畫面 Program寫入程式 在Program寫入官方範例\nusing NLog;\rusing NLog.Web;\rvar logger = LogManager.Setup().LoadConfigurationFromAppSettings().GetCurrentClassLogger();\rlogger.Debug(\u0026#34;init main\u0026#34;);\rtry {\rvar builder = WebApplication.CreateBuilder(args);\r//將NLog註冊到此專案內\rbuilder.Logging.ClearProviders();\r//設定log紀錄的最小等級\rbuilder.Logging.SetMinimumLevel(Microsoft.Extensions.Logging.LogLevel.Information);\rbuilder.Host.UseNLog();\rbuilder.Services.AddControllers();\r// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\rbuilder.Services.AddEndpointsApiExplorer();\rbuilder.Services.AddSwaggerGen();\rvar app = builder.Build();\r// Configure the HTTP request pipeline.\rif (app.Environment.IsDevelopment()) {\rapp.UseSwagger();\rapp.UseSwaggerUI();\r}\rapp.UseHttpsRedirection();\rapp.UseAuthorization();\rapp.MapControllers();\rapp.Run();\r} catch (Exception ex) {\r// 捕獲設定錯誤的錯誤紀錄\rlogger.Error(ex, \u0026#34;Stopped program because of exception\u0026#34;);\rthrow;\r} finally {\r//須確定在關閉時，把nlog關閉\rLogManager.Shutdown();\r} 只擷取部分畫面 設定appsetting.json 將原先存在的default移除\n{\r\u0026#34;Logging\u0026#34;: {\r\u0026#34;LogLevel\u0026#34;: {\r\u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34;\r}\r},\r\u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;\r} controller寫入log 在預設的controller裡面寫入Log，如下圖紅框處\n//寫在建構子內\r_logger.LogDebug(1, \u0026#34;NLog injected into HomeController\u0026#34;);\r//寫在action內\r_logger.LogInformation(\u0026#34;這是範例程式預設的controller!!\u0026#34;); 執行結果 點try it out後點execute，確定執行完成查看console檔案(執行專案會啟動一個terminal) 步驟六有在設定檔內設定log存放路徑，c:\\temp\\internal-nlog-AspNetCore.txt 結論 完成範例說明後建議使用Serilog，因為相對來說單純一點，對於設定上來說nlog真的比較複雜。\n參考 官方範例\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-nlog%E7%AF%84%E4%BE%8B/","summary":"目的 在webapi專案下使用NLog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 NLog NLog.Web.AspNetCore 新增nlog.config檔案 在根目錄新增nlog.config檔案 nlog.config寫入程式 在nlog.config寫入官方範例\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt;\r\u0026lt;nlog xmlns=\u0026#34;http://www.nlog-project.org/schemas/NLog.xsd\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rautoReload=\u0026#34;true\u0026#34;\rinternalLogLevel=\u0026#34;Info\u0026#34;\rinternalLogFile=\u0026#34;c:\\temp\\internal-nlog-AspNetCore.txt\u0026#34;\u0026gt;\r\u0026lt;!-- enable asp.net core layout renderers --\u0026gt;\r\u0026lt;extensions\u0026gt;\r\u0026lt;add assembly=\u0026#34;NLog.Web.AspNetCore\u0026#34;/\u0026gt;\r\u0026lt;/extensions\u0026gt;\r\u0026lt;!-- the targets to write to --\u0026gt;\r\u0026lt;targets\u0026gt;\r\u0026lt;!-- File Target for all log messages with basic details --\u0026gt;\r\u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;allfile\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-all-${shortdate}.log\u0026#34;\rlayout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${level:uppercase=true}|${logger}|${message} ${exception:format=tostring}\u0026#34; /\u0026gt;\r\u0026lt;!-- File Target for own log messages with extra web details using some ASP.","title":"dotnet6 NLog範例"},{"content":"目的 讀取appsetting設定檔 二階段初始化 為了簡單化故將Log存入SQLite 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore Serilog.Sinks.SQLite 編輯Program.cs檔 using Serilog; //第一階段初始化 // var builder = WebApplication.CreateBuilder(args);未使用二階段參數化，builder會跑到try外面 Log.Logger = new LoggerConfiguration() //.ReadFrom.Configuration(builder.Configuration) .CreateBootstrapLogger(); try { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //第二階段初始化可以取得appsetting的內容，如不使用第二階段初始化， //會需要將 var builder宣告式會移出try(如上方註解處)，就會有風險未捕獲builder的錯誤 builder.Host.UseSerilog( (hostingContext, services, loggerConfiguration) =\u0026gt; { //使用appsetting loggerConfiguration.ReadFrom.Configuration(builder.Configuration); }); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); //紀錄每個Request的資料，須注意要放在讀取靜態檔案(app.UseStaticFiles())後面，因為靜態檔案的狀態通常不需要紀錄資訊 app.UseSerilogRequestLogging(); //以下省略 編輯appsetting.json 設定Serilog，包含\n最低紀錄標準為Information Microsoft.AspNetCore開頭類別紀錄標準為Warning 寫Log檔到console 寫Log檔到File，並請用日期分割檔案 寫Log檔到SQLite，資料表名稱為Logs，限制DB最大為1M，預設還有一個參數rollOver為true，當達到限制，就會分割DB { \u0026#34;Serilog\u0026#34;: { \u0026#34;MinimumLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Override\u0026#34;: { \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;WriteTo\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;Console\u0026#34; }, { \u0026#34;Name\u0026#34;: \u0026#34;File\u0026#34;, \u0026#34;Args\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;./logs/log-.txt\u0026#34;, \u0026#34;rollingInterval\u0026#34;: \u0026#34;Day\u0026#34; } }, { \u0026#34;Name\u0026#34;: \u0026#34;SQLite\u0026#34;, \u0026#34;Args\u0026#34;: { \u0026#34;sqliteDbPath\u0026#34;: \u0026#34;../../../logs/log.sqlite\u0026#34;, \u0026#34;tableName\u0026#34;: \u0026#34;Logs\u0026#34;, \u0026#34;maxDatabaseSize\u0026#34;: 1 } } ] }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } 編輯WeatherForecastController.cs類別檔 [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //新增一個類型 var StudentObject = new Student() { Id = 4, Name = \u0026#34;Bill\u0026#34;, Age = 20 }; //新增一個匿名類型 var position = new { Latitude = 25, Longitude = 134 }; //寫log等級為error的log，當需要紀錄物件時需要透過{@該物件}來表示 _logger.LogError(\u0026#34;Error Value: {@StudentObject}\u0026#34;, StudentObject); _logger.LogError(\u0026#34;Error Value: {@position}\u0026#34;, position); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } public class Student { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果 執行後查看Log檔 點擊txt檔案後會看到我們所寫的Log檔案，會發現\n第一個紅框處非匿名類型多一個$type跟你說明是什麼類型 第二個紅框處是由於在Program.cs加入了app.UseSerilogRequestLogging();會記錄使用Get請求呼叫了WeatherForecast回傳狀態碼200用了31ms的時間 參考 Serilog m@rcus 學習筆記\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-serilog%E9%80%B2%E9%9A%8E%E7%AF%84%E4%BE%8B/","summary":"目的 讀取appsetting設定檔 二階段初始化 為了簡單化故將Log存入SQLite 建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore Serilog.Sinks.SQLite 編輯Program.cs檔 using Serilog; //第一階段初始化 // var builder = WebApplication.CreateBuilder(args);未使用二階段參數化，builder會跑到try外面 Log.Logger = new LoggerConfiguration() //.ReadFrom.Configuration(builder.Configuration) .CreateBootstrapLogger(); try { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //第二階段初始化可以取得appsetting的內容，如不使用第二階段初始化， //會需要將 var builder宣告式會移出try(如上方註解處)，就會有風險未捕獲builder的錯誤 builder.Host.UseSerilog( (hostingContext, services, loggerConfiguration) =\u0026gt; { //使用appsetting loggerConfiguration.ReadFrom.Configuration(builder.Configuration); }); var app = builder.","title":"dotnet6 Serilog進階範例"},{"content":"目的 在webapi專案下使用serilog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore 編輯Program.cs檔 在最外層包一個try catch目的是為了捕捉啟動階段的錯誤\nusing Serilog; using Serilog.Events; Log.Logger = new LoggerConfiguration() //Serilog要寫入的最低等級為Information .MinimumLevel.Information() //Microsoft.AspNetCore開頭的類別等極為warning .MinimumLevel.Override(\u0026#34;Microsoft.AspNetCore\u0026#34;, LogEventLevel.Warning) //寫log到Logs資料夾的log.txt檔案中，並且以天為單位做檔案分割 .WriteTo.File(\u0026#34;./Logs/log.txt\u0026#34;, rollingInterval: RollingInterval.Day) .CreateLogger(); try { Log.Information(\u0026#34;Starting web host\u0026#34;); var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //controller可以使用ILogger介面來寫入log紀錄 builder.Host.UseSerilog(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); return 0; } catch (Exception ex) { Log.Fatal(ex, \u0026#34;Host terminated unexpectedly\u0026#34;); return 1; } finally { Log.CloseAndFlush(); } 編輯WeatherForecastController.cs類別檔 因預設就有注入ILogger，故可以直接使用\n因微軟內建的介面ILogger等級區分與Serilog不一樣，故提供對照表格\nILogger Serilog Level 0 Trace Verbose Level 1 Debug Debug Level 2 Information Information Level 3 Warning Warning Level 4 Error Error Level 5 Critical Fatal Level 6 None Serilog沒有 private readonly ILogger\u0026lt;WeatherForecastController\u0026gt; _logger; public WeatherForecastController(ILogger\u0026lt;WeatherForecastController\u0026gt; logger) { _logger = logger; } [HttpGet(Name = \u0026#34;GetWeatherForecast\u0026#34;)] public IEnumerable\u0026lt;WeatherForecast\u0026gt; Get() { //輸出log _logger.LogInformation(\u0026#34;This is Controller\u0026#34;); _logger.LogError(\u0026#34;Test Error\u0026#34;); return Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = DateTime.Now.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }) .ToArray(); } 執行結果 F5執行後，依照下列步驟操作，並確認結果 執行後就可以到我們的專案檔路徑下查看Logs資料夾 點進去資料夾後就可以看到以日期為單位的txt檔案 參考 余小章 Will保哥 官方文件\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-serilog%E7%AF%84%E4%BE%8B/","summary":"目的 在webapi專案下使用serilog套件\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Serilog.AspNetCore 編輯Program.cs檔 在最外層包一個try catch目的是為了捕捉啟動階段的錯誤\nusing Serilog; using Serilog.Events; Log.Logger = new LoggerConfiguration() //Serilog要寫入的最低等級為Information .MinimumLevel.Information() //Microsoft.AspNetCore開頭的類別等極為warning .MinimumLevel.Override(\u0026#34;Microsoft.AspNetCore\u0026#34;, LogEventLevel.Warning) //寫log到Logs資料夾的log.txt檔案中，並且以天為單位做檔案分割 .WriteTo.File(\u0026#34;./Logs/log.txt\u0026#34;, rollingInterval: RollingInterval.Day) .CreateLogger(); try { Log.Information(\u0026#34;Starting web host\u0026#34;); var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //controller可以使用ILogger介面來寫入log紀錄 builder.Host.UseSerilog(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); return 0; } catch (Exception ex) { Log.","title":"dotnet6 Serilog範例"},{"content":"目的 說明EFCore基本語法，EFCore的基礎為Linq，所以使用上與Linq邏輯一模一樣，只是語法有些微差異。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample_Advanced.Models; namespace EFCoreExample_Advanced.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.UseSqlite(\u0026#34;Data Source=Student.sqlite\u0026#34;); } //設定student資料表 public DbSet\u0026lt;Student\u0026gt; Students { get; set; } } } 編輯Program.cs檔 //別忘了using using EFCoreExample_Advanced.DBContext; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊EFCoreContext builder.Services.AddDbContext\u0026lt;EFCoreContext\u0026gt;(); //下面省略 到套件管理器主控台下Terminal指令 檢視\u0026gt;其他視窗\u0026gt;套件管理器主控台 下方會出現命令列 輸入dir會顯示目錄檔案及子目錄清單 輸入cd EFCoreExample_Advanced移動到專案檔底下後再輸入dir確認是否到正確路徑 輸入dotnet tool install --global dotnet-ef在全域安裝EFCore CLI工具(如果已經安裝，會出現下圖訊息，即可忽略此步驟) 輸入dotnet ef migrations add CreateInitial初始化SQLite 輸入dotnet ef database update更新SQLite資料表 成功就會自動產生Migrations資料夾 編輯WeatherForecastController檔案編輯 寫新的對外API：QueryAsync [HttpGet(\u0026#34;QueryAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryAsync() { //透過ToListAsync方法就可以將Students所有資料取出 var Result = await _context.Students.ToListAsync(); return Ok(Result); } 寫新的對外API：QueryFirstOrDefaultAsync [HttpGet(\u0026#34;QueryFirstOrDefaultAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryFirstOrDefaultAsync() { //取得第一筆 var Result = await _context.Students.FirstOrDefaultAsync(); return Ok(Result); } 交易機制 當有多張表需要異動時，為了確認資料的一致性，會需要透過交易機制做保護，只有全部成功或全部失敗。 [HttpGet(\u0026#34;TransactionsAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; TransactionsAsync() { //開始資料庫交易 using var trans = _context.Database.BeginTransaction(); //建立一筆資料 var data = new Student() { Name = \u0026#34;BillHuang\u0026#34;, Age = 20 }; //新增到Students資料表中 _context.Students.Add(data); //執行，此步驟還不會真的異動到資料 await _context.SaveChangesAsync(); //取得第一筆資料 var Result = await _context.Students.FirstOrDefaultAsync(); //當執行了Commit後才會將上面的異動存到資料庫 trans.Commit(); return Ok(Result); } 參考 N+1 交易\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-efcore%E8%AA%9E%E6%B3%95%E8%AA%AA%E6%98%8E/","summary":"目的 說明EFCore基本語法，EFCore的基礎為Linq，所以使用上與Linq邏輯一模一樣，只是語法有些微差異。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample_Advanced.Models; namespace EFCoreExample_Advanced.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.","title":"dotnet6 EFCore語法說明"},{"content":"目的 透過EFCore對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample.Models; namespace EFCoreExample.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.UseSqlite(\u0026#34;Data Source=Student.sqlite\u0026#34;); } //設定student資料表 public DbSet\u0026lt;Student\u0026gt; Students { get; set; } } } 編輯Program.cs檔 //別忘了using using EFCoreExample.DBContext; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); //註冊EFCoreContext builder.Services.AddDbContext\u0026lt;EFCoreContext\u0026gt;(); //下面省略 到套件管理器主控台下Terminal指令 檢視\u0026gt;其他視窗\u0026gt;套件管理器主控台 下方會出現命令列 輸入dir會顯示目錄檔案及子目錄清單 輸入cd EFCoreExample移動到專案檔底下後再輸入dir確認是否到正確路徑 輸入dotnet tool install --global dotnet-ef在全域安裝EFCore CLI工具(如果已經安裝，會出現下圖訊息，即可忽略此步驟) 輸入dotnet ef migrations add CreateInitial初始化SQLite 輸入dotnet ef database update更新SQLite資料表 成功就會自動產生Migrations資料夾 編輯WeatherForecastController.cs類別檔 將EFCoreContext注入WeatherForecastController.cs 將預設的API註解 寫新的對外API // [HttpGet(\u0026#34;InsertAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; InsertAsync() { //新增一筆資料 var data = new Student() { Name = \u0026#34;BillHuang\u0026#34;, Age = 20 }; //加到Students這張table內 _context.Students.Add(data); //執行，並回傳成功數量 return Ok(await _context.SaveChangesAsync()); } 執行結果 F5執行後，依照下列步驟操作，並確認結果 參考 efcore影片介紹 余小章 @ 大內殿堂\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-efcore%E7%AF%84%E4%BE%8B/","summary":"目的 透過EFCore對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Microsoft.EntityFrameworkCore.Sqlite Microsoft.EntityFrameworkCore.Design 新增Student.cs類別檔 新增Models資料夾，並在裡面新增Student.cs類別檔 編輯Student.cs類別檔 public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 新增EFCoreContext.cs類別檔 新增DBContext資料夾，並在裡面新增EFCoreContext.cs類別檔 編輯EFCoreContext.cs類別檔 //別忘了using using Microsoft.EntityFrameworkCore; using EFCoreExample.Models; namespace EFCoreExample.DBContext { //繼承DbContext public class EFCoreContext : DbContext { //複寫OnConfiguring protected override void OnConfiguring(DbContextOptionsBuilder options) { //指定連線字串，連到SQLite options.","title":"dotnet6 EFCore範例"},{"content":"目的 說明Dapper基本語法\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite 編輯WeatherForecastController檔案 將預設的API註解 基本設定 /// \u0026lt;summary\u0026gt; /// 初始化SQLite /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static async Task InitSqliteAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //判斷是否有Student.sqlite檔案 if (!System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //新增一張表，就會建立.sqlite檔案 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await conn.ExecuteAsync(SQL.ToString()); } //Task不建議使用void，當不需要回傳值時會改用Task.CompletedTask說明已經完成，可以下一個步驟了。 await Task.CompletedTask; } public class Student { public int Id { get; set; } //Name預設值為Billhuang，與以前建構子的寫法一樣，如下方寫法 //public Student(){Name=\u0026#34;BillHuang\u0026#34;;} public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 寫新的對外API：ExcuteAsync /// \u0026lt;summary\u0026gt; /// ExecuteAsync可用於insert、delete、update /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;ExcuteAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; ExcuteAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;INSERT INTO Student (Name, Age) VALUES (@Name, @Age);\u0026#34;); DynamicParameters parameters = new(); parameters.Add(\u0026#34;Name\u0026#34;, \u0026#34;BillHuang\u0026#34;); parameters.Add(\u0026#34;Age\u0026#34;, 20); var Result = await conn.ExecuteAsync(SQL.ToString(), parameters); return Ok(Result); } 寫新的對外API：QueryAsync /// \u0026lt;summary\u0026gt; /// QueryAsync可用於select /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;QueryAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;select * from Student\u0026#34;); var Result = await conn.QueryAsync\u0026lt;Student\u0026gt;(SQL.ToString()); return Ok(Result); } 寫新的對外API：QueryFirstOrDefaultAsync 取得第一筆的方法有四種，個人都是使用QueryFirstOrDefault，並判斷是否為null，如下列範例。 指令 沒有值 有一個值 有多個值 QueryFirst exception V 取第一筆 QuerySingle exception V exception QueryFirstOrDefault null V 取第一筆 QuerySingleOrDefault null V exception /// \u0026lt;summary\u0026gt; /// 取得select第一筆 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;QueryFirstOrDefaultAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; QueryFirstOrDefaultAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;select * from Student\u0026#34;); var Result = await conn.QueryFirstOrDefaultAsync\u0026lt;Student\u0026gt;(SQL.ToString()); if (Result is not null) { return Ok(Result); } return Ok(Result); } 交易機制 當有多張表需要異動時，為了確認資料的一致性，會需要透過交易機制做保護，只有全部成功或全部失敗。 /// \u0026lt;summary\u0026gt; /// 交易機制，簡單說就是全部成功才算成功，不然就全部取消。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;TransactionsAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; TransactionsAsync() { using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); //開啟連線，前面沒有這行是因為在在執行語法時(Execute、Query)會自動檢查是否連接資料庫 conn.Open(); //開始資料庫交易 var trans = conn.BeginTransaction(); var SQL = new StringBuilder(); //初始化SQLite await InitSqliteAsync(); SQL.Append(\u0026#34;INSERT INTO Student (Name, Age) VALUES (@Name, @Age);\u0026#34;); DynamicParameters parameters = new(); parameters.Add(\u0026#34;Name\u0026#34;, \u0026#34;BillHuang\u0026#34;); parameters.Add(\u0026#34;Age\u0026#34;, 20); //執行完並不會真的異動資料 await conn.ExecuteAsync(SQL.ToString(), parameters, trans); SQL.Clear(); SQL.Append(\u0026#34;select * from Student\u0026#34;); var Result = await conn.QueryFirstOrDefaultAsync\u0026lt;Student\u0026gt;(SQL.ToString(), trans); //當程式執行到Commit才是真的執行成功。 trans.Commit(); return Ok(); } 範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-dapper%E8%AA%9E%E6%B3%95%E8%AA%AA%E6%98%8E/","summary":"目的 說明Dapper基本語法\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite 編輯WeatherForecastController檔案 將預設的API註解 基本設定 /// \u0026lt;summary\u0026gt; /// 初始化SQLite /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static async Task InitSqliteAsync() { //建立SQLite連線 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //判斷是否有Student.sqlite檔案 if (!System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //新增一張表，就會建立.sqlite檔案 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await conn.ExecuteAsync(SQL.ToString()); } //Task不建議使用void，當不需要回傳值時會改用Task.","title":"dotnet6 Dapper語法說明"},{"content":"目的 透過dapper對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite(微軟官方還是SQLite官方?黑暗執行緒前輩有做說明，我的選擇比較單純有微軟用微軟) 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API /// \u0026lt;summary\u0026gt; /// 檢查有沒有sqlite檔案，沒有就新增，並增加一筆資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;InsertAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; InsertAsync() { //連接sqlite資料庫 using var connection = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //當找不到sqlite檔案時，建立新表，新表創建後就會產生sqlite檔案了 if (System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //組語法，新建名為Student的表 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); //Id欄位設定數字型別為PKey，並且自動遞增 SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); //Name欄位設定為VARCHAR(32)不允許是null SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); //Age欄位設定為int SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await connection.ExecuteAsync(SQL.ToString()); //清除字串內的值 SQL.Clear(); } //組語法 SQL.Append(\u0026#34;INSERT INTO Student (Name, Age) VALUES (@Name, @Age);\u0026#34;); //建立SQL參數化要使用的變數 DynamicParameters parameters = new(); //參數1 parameters.Add(\u0026#34;Name\u0026#34;, \u0026#34;BillHuang\u0026#34;); //參數2 parameters.Add(\u0026#34;Age\u0026#34;, 20); //執行語法，insert一筆資料到Student var Result = await conn.ExecuteAsync(SQL.ToString(), parameters); //回傳執行成功的數量 return Ok(Result); } /// \u0026lt;summary\u0026gt; /// 取得Student所有資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;SelectAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; SelectAsync() { //連接sqlite資料庫 using var conn = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //組語法 SQL.Append(\u0026#34;select * from Student\u0026#34;); //執行，並且將執行結果存為強型別 var Result = await conn.QueryAsync\u0026lt;Student\u0026gt;(SQL.ToString()); //回傳結果 return Ok(Result); } public class Student { public int Id { get; set; } public string Name { get; set; } = \u0026#34;BillHuang\u0026#34;; public int Age { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果\nInsert Select 參考 微軟官方還是SQLite官方\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-dapper%E7%AF%84%E4%BE%8B/","summary":"目的 透過dapper對db做查詢，為了降低門檻採用SQLite當範例資料庫。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Dapper Microsoft.Data.Sqlite(微軟官方還是SQLite官方?黑暗執行緒前輩有做說明，我的選擇比較單純有微軟用微軟) 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API /// \u0026lt;summary\u0026gt; /// 檢查有沒有sqlite檔案，沒有就新增，並增加一筆資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;InsertAsync\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; InsertAsync() { //連接sqlite資料庫 using var connection = new SqliteConnection(\u0026#34;Data Source=Student.sqlite\u0026#34;); var SQL = new StringBuilder(); //當找不到sqlite檔案時，建立新表，新表創建後就會產生sqlite檔案了 if (System.IO.File.Exists(@\u0026#34;.\\Student.sqlite\u0026#34;)) { //組語法，新建名為Student的表 SQL.Append(\u0026#34;CREATE TABLE Student( \\n\u0026#34;); //Id欄位設定數字型別為PKey，並且自動遞增 SQL.Append(\u0026#34;Id INTEGER PRIMARY KEY AUTOINCREMENT, \\n\u0026#34;); //Name欄位設定為VARCHAR(32)不允許是null SQL.Append(\u0026#34;Name VARCHAR(32) NOT NULL, \\n\u0026#34;); //Age欄位設定為int SQL.Append(\u0026#34;Age INTEGER) \\n\u0026#34;); //執行sql語法 await connection.","title":"dotnet6 Dapper範例"},{"content":"目的 使用epplus製作長條圖\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)] public ActionResult ImportExcel() { //建立excel所有操作的實例 using ExcelPackage excelPackage = new(); var ws = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;); Random Random = new Random(); //ws.Cells[上下(row),左右(col)] ws.Cells[1, 2].Value = \u0026#34;第一季\u0026#34;; ws.Cells[1, 3].Value = \u0026#34;第二季\u0026#34;; ws.Cells[1, 4].Value = \u0026#34;第三季\u0026#34;; ws.Cells[1, 5].Value = \u0026#34;第四季\u0026#34;; ws.Cells[2, 1].Value = \u0026#34;A組\u0026#34;; ws.Cells[3, 1].Value = \u0026#34;B組\u0026#34;; ws.Cells[4, 1].Value = \u0026#34;C組\u0026#34;; ws.Cells[5, 1].Value = \u0026#34;D組\u0026#34;; for (int i = 2; i \u0026lt;= 5; i++) { for (int j = 2; j \u0026lt;= 5; j++) { ws.Cells[i, j].Value = Random.Next(70, 150); } } //建立長條圖 var BarChart = ws.Drawings.AddBarChart(\u0026#34;BarChart\u0026#34;, eBarChartType.ColumnClustered); //長條圖名稱 BarChart.Title.Text = \u0026#34;年度季報表\u0026#34;; //長條圖的位置 BarChart.SetPosition(6, 0, 6, 0); //長條圖大小 BarChart.SetSize(400, 400); //第一個顏色長條圖BarChart.Series.Add(數據區間，x軸名稱區間)=\u0026gt;數據區間從(2,2)到(2,5)，X軸名稱(第一季、第二季、第三季、第四季) var Ateam = BarChart.Series.Add(ExcelCellBase.GetAddress(2, 2, 2, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); //第一條顏色的名稱(A組) Ateam.Header = ws.Cells[2, 1].Text; var Bteam = BarChart.Series.Add(ExcelCellBase.GetAddress(3, 2, 3, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); Bteam.Header = ws.Cells[3, 1].Text; var Cteam = BarChart.Series.Add(ExcelCellBase.GetAddress(4, 2, 4, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); Cteam.Header = ws.Cells[4, 1].Text; var Dteam = BarChart.Series.Add(ExcelCellBase.GetAddress(5, 2, 5, 5), ExcelCellBase.GetAddress(1, 2, 1, 5)); Dteam.Header = ws.Cells[5, 1].Text; //樣式使用1 BarChart.StyleManager.SetChartStyle(ePresetChartStyle.HistogramChartStyle1); //將檔案匯出 return File(excelPackage.GetAsByteArray(), \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;, \u0026#34;製作長條圖\u0026#34;); } 範例太長，只擷取部分 執行結果 範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-epplus%E5%9C%96%E8%A1%A8%E7%AF%84%E4%BE%8B/","summary":"目的 使用epplus製作長條圖\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)] public ActionResult ImportExcel() { //建立excel所有操作的實例 using ExcelPackage excelPackage = new(); var ws = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;); Random Random = new Random(); //ws.Cells[上下(row),左右(col)] ws.Cells[1, 2].Value = \u0026#34;第一季\u0026#34;; ws.Cells[1, 3].Value = \u0026#34;第二季\u0026#34;; ws.Cells[1, 4].Value = \u0026#34;第三季\u0026#34;; ws.Cells[1, 5].Value = \u0026#34;第四季\u0026#34;; ws.Cells[2, 1].","title":"dotnet6 EPPlus圖表範例"},{"content":"目的 將資料匯出成excel\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)]\rpublic ActionResult ImportExcel() {\r//建立excel所有操作的實例\rusing ExcelPackage excelPackage = new();\r//properties為excel的屬性，開啟excel後要特別去查看屬性才能看到的資訊\rexcelPackage.Workbook.Properties.Author = \u0026#34;Bill Huang\u0026#34;;\rexcelPackage.Workbook.Properties.Title = \u0026#34;範例檔案\u0026#34;;\rexcelPackage.Workbook.Properties.Created = DateTime.Now;\r//建立第一頁工作表(下方所顯示的頁簽)\rExcelWorksheet worksheet = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;);\rint i = 1;\rforeach (var c in Summaries) {\r//選擇指定欄位將資料放入\rworksheet.Cells[i,1].Value = c;\ri++;\r}\r//將檔案匯出\rreturn File(excelPackage.GetAsByteArray(), \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;, \u0026#34;excel檔案預設名稱\u0026#34;);\r} 執行結果 F5執行後，依照下列步驟操作，並將檔案下載下來 參考 伊果的沒人看筆記本\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-epplus%E7%AF%84%E4%BE%8B/","summary":"目的 將資料匯出成excel\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Epplus 設定appsetting檔案 為了避免LicenseException，故需要在appsetting加入下列文字\n\u0026#34;EPPlus\u0026#34;: {\r\u0026#34;ExcelPackage\u0026#34;: {\r\u0026#34;LicenseContext\u0026#34;: \u0026#34;Commercial\u0026#34; //The license context used\r}\r} 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(Name = \u0026#34;Import\u0026#34;)]\rpublic ActionResult ImportExcel() {\r//建立excel所有操作的實例\rusing ExcelPackage excelPackage = new();\r//properties為excel的屬性，開啟excel後要特別去查看屬性才能看到的資訊\rexcelPackage.Workbook.Properties.Author = \u0026#34;Bill Huang\u0026#34;;\rexcelPackage.Workbook.Properties.Title = \u0026#34;範例檔案\u0026#34;;\rexcelPackage.Workbook.Properties.Created = DateTime.Now;\r//建立第一頁工作表(下方所顯示的頁簽)\rExcelWorksheet worksheet = excelPackage.Workbook.Worksheets.Add(\u0026#34;第一頁\u0026#34;);\rint i = 1;\rforeach (var c in Summaries) {\r//選擇指定欄位將資料放入\rworksheet.","title":"dotnet6 EPPlus範例"},{"content":"目的 將預設回傳的Camel-Case(temperatureCelsius)改為Pascal Case(TemperatureCelsius)\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar options = new JsonSerializerOptions {\rPropertyNamingPolicy = null,\r};\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18,\u0026#34;\u0026#34;TemperatureCelsius\u0026#34;\u0026#34;:52}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString,options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\rpublic int TemperatureCelsius { get; set; }\r} Program寫入程式 builder.Services.AddControllers()\r.AddJsonOptions(options =\u0026gt; {\r//預設為小駝峰命名，將此參數改為null即可使用大駝峰命名\roptions.JsonSerializerOptions.PropertyNamingPolicy = null;\r}); 執行結果 參考 大駝峰命名\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-%E6%9B%B4%E6%94%B9%E5%9B%9E%E5%82%B3json%E6%99%82%E7%82%BA%E5%A4%A7%E9%A7%9D%E5%B3%B0%E5%91%BD%E5%90%8D/","summary":"目的 將預設回傳的Camel-Case(temperatureCelsius)改為Pascal Case(TemperatureCelsius)\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar options = new JsonSerializerOptions {\rPropertyNamingPolicy = null,\r};\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18,\u0026#34;\u0026#34;TemperatureCelsius\u0026#34;\u0026#34;:52}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString,options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\rpublic int TemperatureCelsius { get; set; }\r} Program寫入程式 builder.","title":"dotnet6 更改回傳Json時為大駝峰命名"},{"content":"目的 序列化時不自動將非ASCII轉為Unicode\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using [HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar options = new JsonSerializerOptions {\r//美化輸出，會有空白字元\rWriteIndented = true,\r//將所有語言都不進行轉換\rEncoder = JavaScriptEncoder.Create(UnicodeRanges.All)\r};\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18,\r};\rvar Result = JsonSerializer.Serialize(Test, options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 中文就不會是unicode了 參考 How to serialize and deserialize\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-%E8%A7%A3%E6%B1%BAsystem.text.json%E5%BA%8F%E5%88%97%E5%8C%96%E5%BE%8C%E6%9C%83%E5%B0%87%E6%89%80%E6%9C%89%E9%9D%9Eascii%E8%BD%89%E7%82%BAunicode/","summary":"目的 序列化時不自動將非ASCII轉為Unicode\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using [HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar options = new JsonSerializerOptions {\r//美化輸出，會有空白字元\rWriteIndented = true,\r//將所有語言都不進行轉換\rEncoder = JavaScriptEncoder.Create(UnicodeRanges.All)\r};\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18,\r};\rvar Result = JsonSerializer.Serialize(Test, options);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 中文就不會是unicode了 參考 How to serialize and deserialize","title":"dotnet6 解決System.Text.Json序列化後會將所有非ASCII轉為Unicode"},{"content":"目的 不使用Newtonsoft.Json，改採.net6內建的System.Text.Json System.Text.Json更著重在效能與安全性，大多數人應該都跟我一樣只會使用基本的序列化及反序列化。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18\r};\rvar Result = JsonSerializer.Serialize(Test);\rreturn Ok(Result);\r}\r/// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 點選Try it out 點選Execute 查看執行結果1(序列化) 查看執行結果2(反序列化) 延伸問題 在不做任何設定的情況下，內建的序列化會有些微差異\n序列化預設會將所有非ASCII轉為Unicode代碼，例如：中文名=\u0026gt;\\u4E2D\\u6587\\u540D 使用ActionResult中的JsonResult回傳時會將開頭改為小寫\n反序列化後輸出為小寫的key(如結果2)，原先的TestClass是大寫的Name與Age 兩個問題都會在另一個章節補充說明\n參考 Compare Newtonsoft.Json to System.Text.Json, and migrate to System.Text.Json\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-text.json%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%84%E4%BE%8B/","summary":"目的 不使用Newtonsoft.Json，改採.net6內建的System.Text.Json System.Text.Json更著重在效能與安全性，大多數人應該都跟我一樣只會使用基本的序列化及反序列化。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 編輯WeatherForecastController檔案 將預設的API註解，寫入新的Action，預設不會引用System.Text.Json，記得在最上面using /// \u0026lt;summary\u0026gt;\r/// 序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonSerialize\u0026#34;)]\rpublic ActionResult JsonSerialize() {\rvar Test = new TestClass() {\rName = \u0026#34;中文名\u0026#34;,\rAge = 18\r};\rvar Result = JsonSerializer.Serialize(Test);\rreturn Ok(Result);\r}\r/// \u0026lt;summary\u0026gt;\r/// 反序列化\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r[HttpGet(\u0026#34;JsonDeserialize\u0026#34;)]\rpublic ActionResult JsonDeserialize() {\rvar jsonString = @\u0026#34;{\u0026#34;\u0026#34;Name\u0026#34;\u0026#34;:\u0026#34;\u0026#34;中文名\u0026#34;\u0026#34;,\u0026#34;\u0026#34;Age\u0026#34;\u0026#34;:18}\u0026#34;;\rvar Result = JsonSerializer.Deserialize\u0026lt;TestClass\u0026gt;(jsonString);\rreturn Ok(Result);\r}\rpublic class TestClass {\rpublic string Name { get; set; }\rpublic int Age { get; set; }\r} 執行結果 點選Try it out 點選Execute 查看執行結果1(序列化) 查看執行結果2(反序列化) 延伸問題 在不做任何設定的情況下，內建的序列化會有些微差異","title":"dotnet6 Text.Json範例"},{"content":"目的 在swagger內使用jwt token測試API\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 NuGet加入套件 透過NuGet安裝\nJWT Microsoft.AspNetCore.Authentication.JwtBearer Microsoft.IdentityModel.Tokens System.IdentityModel.Tokens.Jwt 新增Helpers資料夾並在裡面新增JwtHelpers.cs類別檔案 jwt範例使用保哥範例來做修改，目的只是為了取得jwt token\npublic class JwtHelper { private readonly JwtSettingsOptions _settings; public JwtHelper(IOptionsMonitor\u0026lt;JwtSettingsOptions\u0026gt; settings) { //注入appsetting的json _settings = settings.CurrentValue; } public string GenerateToken(string userName, int expireMinutes = 120) { //發行人 var issuer = _settings.Issuer; //加密的key，拿來比對jwt-token沒有 var signKey = _settings.SignKey; 建立JWT-Token var token = JwtBuilder.Create() //所採用的雜湊演算法 .WithAlgorithm(new HMACSHA256Algorithm()) // symmetric //加密key .WithSecret(signKey) //角色 .AddClaim(\u0026#34;roles\u0026#34;, \u0026#34;admin\u0026#34;) //JWT ID .AddClaim(\u0026#34;jti\u0026#34;, Guid.NewGuid().ToString()) //發行人 .AddClaim(\u0026#34;iss\u0026#34;, issuer) //使用對象名稱 .AddClaim(\u0026#34;sub\u0026#34;, userName) // User.Identity.Name //過期時間 .AddClaim(\u0026#34;exp\u0026#34;, DateTimeOffset.UtcNow.AddMinutes(expireMinutes).ToUnixTimeSeconds()) //此時間以前是不可以使用 .AddClaim(\u0026#34;nbf\u0026#34;, DateTimeOffset.UtcNow.ToUnixTimeSeconds()) //發行時間 .AddClaim(\u0026#34;iat\u0026#34;, DateTimeOffset.UtcNow.ToUnixTimeSeconds()) //使用者全名 .AddClaim(ClaimTypes.Name, userName) //進行編碼 .Encode(); return token; } } //將appsetting轉為強行別所使用 public class JwtSettingsOptions { public string Issuer { get; set; } = \u0026#34;\u0026#34;; public string SignKey { get; set; } = \u0026#34;\u0026#34;; } 因篇幅過長，只擷取JwtHelpers.cs部分內容，記得要using下列命名空間\nusing JWT.Algorithms; using JWT.Builder; using Microsoft.Extensions.Options; using System.Security.Claims; 新增Filters資料夾並在裡面新增AuthorizeCheckOperationFilter.cs類別檔案 因為在使用swagger做認證測試時，會遇到一個很惱人的問題，就是當我的某些api並不需要做認證，卻還是會在畫面上顯示鎖頭\n第一支並沒有attribute，無須認證 第二支為AllowAnonymous，無須認證 第三支為Authorize，需要認證 public class AuthorizeCheckOperationFilter : IOperationFilter { private readonly EndpointDataSource _endpointDataSource; public AuthorizeCheckOperationFilter(EndpointDataSource endpointDataSource) { _endpointDataSource = endpointDataSource; } public void Apply(OpenApiOperation operation, OperationFilterContext context) { 取得所有controller內的action var Descriptor = _endpointDataSource.Endpoints.FirstOrDefault(x =\u0026gt; x.Metadata.GetMetadata\u0026lt;ControllerActionDescriptor\u0026gt;() == context.ApiDescription.ActionDescriptor); //取得包含Authorize的Attribute var Authorize = Descriptor.Metadata.GetMetadata\u0026lt;AuthorizeAttribute\u0026gt;() != null; //取得包含AllowAnonymous的Attribute var AllowAnonymous = Descriptor.Metadata.GetMetadata\u0026lt;AllowAnonymousAttribute\u0026gt;() != null; //如果不需要鎖頭則return回去 if (!Authorize || AllowAnonymous) return; //需要鎖頭則在swagger-UI中定義出來 operation.Security = new List\u0026lt;OpenApiSecurityRequirement\u0026gt; { new() { [ new OpenApiSecurityScheme {Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34;} } ] = new List\u0026lt;string\u0026gt;() } }; } } 編輯WeatherForecastController檔案 注入JwtHelper 第一支為預設沒有attribute的方法 第二支為登入方法，attribute是AllowAnonymous，任何人都可以使用 第三支為登入後才可以取得的資料，attribute是Authorize(Roles = \u0026ldquo;admin\u0026rdquo;)，role需要是admin才可以使用 [HttpGet(\u0026#34;Login\u0026#34;), AllowAnonymous] public ActionResult\u0026lt;string\u0026gt; Login(string username , string password) { var token = _jwtHelpers.GenerateToken(username); return Ok(token); } [HttpGet(\u0026#34;username\u0026#34;), Authorize(Roles = \u0026#34;admin\u0026#34;)] public ActionResult\u0026lt;string\u0026gt; Username() { return Ok(User.Identity?.Name); } 再次編輯Program.cs檔案 分兩個區塊說明\nJWT設定 //清除預設映射 JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear(); //註冊JwtHelper builder.Services.AddSingleton\u0026lt;JwtHelper\u0026gt;(); //使用選項模式註冊 builder.Services.Configure\u0026lt;JwtSettingsOptions\u0026gt;( builder.Configuration.GetSection(\u0026#34;JwtSettings\u0026#34;)); //設定認證方式 builder.Services //使用bearer token方式認證並且token用jwt格式 .AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.TokenValidationParameters = new TokenValidationParameters { // 可以讓[Authorize]判斷角色 RoleClaimType = \u0026#34;roles\u0026#34;, // 預設會認證發行人 ValidateIssuer = true, ValidIssuer = builder.Configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:Issuer\u0026#34;), // 不認證使用者 ValidateAudience = false, // 如果 Token 中包含 key 才需要驗證，一般都只有簽章而已 ValidateIssuerSigningKey = true, // 簽章所使用的key IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration.GetValue\u0026lt;string\u0026gt;(\u0026#34;JwtSettings:SignKey\u0026#34;))) }; }); 2. Swagger-UI調整\n//說明api如何受到保護 options.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { Name = \u0026#34;Authorization\u0026#34;, //選擇類型，type選擇http時，透過swagger畫面做認證時可以省略Bearer前綴詞(如下圖) Type = SecuritySchemeType.Http, //採用Bearer token Scheme = \u0026#34;Bearer\u0026#34;, //bearer格式使用jwt BearerFormat = \u0026#34;JWT\u0026#34;, //認證放在http request的header上 In = ParameterLocation.Header, //描述 Description = \u0026#34;JWT驗證描述\u0026#34; }); //製作額外的過濾器，過濾Authorize、AllowAnonymous，甚至是沒有打attribute options.OperationFilter\u0026lt;AuthorizeCheckOperationFilter\u0026gt;(); Type使用SecuritySchemeType.Http，不用打Bearer Type使用SecuritySchemeType.ApiKey，需要打Bearer與空白以及文字描述會包含Name、In、Description 在下方別忘了使用認證的中介層 執行結果 在登入的api輸入帳號密碼 會回傳一組jwt token 點擊認證按鈕，將token輸入 使用有鎖頭的API 最後可以正確取得回傳值就是成功了 如果不輸入token直接使用有鎖頭的API，就會跳出401錯誤 參考 保哥 伊果的沒人看筆記本 實作Filter JWT規範\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-swagger%E6%8E%88%E6%AC%8A/","summary":"目的 在swagger內使用jwt token測試API\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 NuGet加入套件 透過NuGet安裝\nJWT Microsoft.AspNetCore.Authentication.JwtBearer Microsoft.IdentityModel.Tokens System.IdentityModel.Tokens.Jwt 新增Helpers資料夾並在裡面新增JwtHelpers.cs類別檔案 jwt範例使用保哥範例來做修改，目的只是為了取得jwt token\npublic class JwtHelper { private readonly JwtSettingsOptions _settings; public JwtHelper(IOptionsMonitor\u0026lt;JwtSettingsOptions\u0026gt; settings) { //注入appsetting的json _settings = settings.CurrentValue; } public string GenerateToken(string userName, int expireMinutes = 120) { //發行人 var issuer = _settings.","title":"dotnet6 swagger授權"},{"content":"目的 每次要使用swaggerUI時候範例總是各式各樣，千奇百怪，下列範例是使用官方預設的Swashbuckle套件來教學。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解 program檔案與.net5以前不一樣，保哥的部落格有比較詳細的說明\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 編輯WeatherForecastController檔案 這裡有個重點，如果要增加下一個action時候，預設的範例檔案，需要調整route的設定，才能讀取到，不然會跳錯誤訊息\n加入前 加入後 加入第二個方法 執行結果 就可以成功讀取到兩個方法了 參考 微軟官方\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-swagger%E7%AF%84%E4%BE%8B/","summary":"目的 每次要使用swaggerUI時候範例總是各式各樣，千奇百怪，下列範例是使用官方預設的Swashbuckle套件來教學。\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 選擇.net6版本，支援OpenAPI支援一定要勾選，此選項.net5以後才會有，.net core 3.1並沒有此選項，需要從NuGet安裝，並點建立 專案基本設定 右邊紅框處專案檔點兩下，會開啟專案的xml檔案，額外加入兩行xml資料，目的是要透過編譯器產生文件檔案\n\u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; 加入前 加入後 編輯Program.cs檔案 修改program檔案內容，調整AddSwaggerGen的內容，目的是為了可以讀取我們所寫的註解 program檔案與.net5以前不一樣，保哥的部落格有比較詳細的說明\nbuilder.Services.AddSwaggerGen(options =\u0026gt; { // using System.Reflection; var xmlFilename = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename)); }); 加入前 加入後 編輯WeatherForecastController檔案 這裡有個重點，如果要增加下一個action時候，預設的範例檔案，需要調整route的設定，才能讀取到，不然會跳錯誤訊息\n加入前 加入後 加入第二個方法 執行結果 就可以成功讀取到兩個方法了 參考 微軟官方\n範例檔 GitHub","title":"dotnet6 swagger範例"},{"content":"目的 使用telegram做聊天機器人\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Telegram.Bot 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(\u0026#34;Test\u0026#34;)]\rpublic async Task\u0026lt;string\u0026gt; Test() {\rvar botClient = new TelegramBotClient(\u0026#34;前置作業給的機器人ID\u0026#34;);\r//取得機器人基本資訊\rvar me = await botClient.GetMeAsync();\r//發送訊息到指定頻道\rMessage message = await botClient.SendTextMessageAsync(\rchatId: \u0026#34;前置作業給的頻道ID\u0026#34;,\rtext: \u0026#34;Trying *all the parameters* of `sendMessage` method\u0026#34;);\r//回傳取得的機器人基本資訊\rreturn $\u0026#34;Hello, World! I am user {me.Id} and my name is {me.FirstName}.\u0026#34;;\r} 執行結果 F5執行後，依照下列步驟操作，並確認結果 就可以看到telegram的機器人有發送一個訊息 參考 官方文件 holey\u0026rsquo;s Blog\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-telegram.bot%E7%AF%84%E4%BE%8B/","summary":"目的 使用telegram做聊天機器人\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Telegram.Bot 編輯WeatherForecastController檔案 將預設的API註解 寫新的對外API\n[HttpGet(\u0026#34;Test\u0026#34;)]\rpublic async Task\u0026lt;string\u0026gt; Test() {\rvar botClient = new TelegramBotClient(\u0026#34;前置作業給的機器人ID\u0026#34;);\r//取得機器人基本資訊\rvar me = await botClient.GetMeAsync();\r//發送訊息到指定頻道\rMessage message = await botClient.SendTextMessageAsync(\rchatId: \u0026#34;前置作業給的頻道ID\u0026#34;,\rtext: \u0026#34;Trying *all the parameters* of `sendMessage` method\u0026#34;);\r//回傳取得的機器人基本資訊\rreturn $\u0026#34;Hello, World! I am user {me.Id} and my name is {me.FirstName}.\u0026#34;;\r} 執行結果 F5執行後，依照下列步驟操作，並確認結果 就可以看到telegram的機器人有發送一個訊息 參考 官方文件 holey\u0026rsquo;s Blog","title":"dotnet6 Telegram.Bot範例"},{"content":"目的 在使用telegram機器人時，需要先在telegram新增要使用的機器人。\n搜尋 搜尋@botfather 開始 點擊start 輸入/newbot指令 輸入/newbot指令後，對話欄會請你輸入你的名稱。 設定聊天機器人的顯示名稱 這邊所輸入的名稱，並沒有限制要Bot或_bot當結尾。 設定機器人帳號 其他人可以透過查詢帳號找到我們所建立的機器人。\n當要輸入機器人帳號時，會限制要Bot或_bot結尾，需要特別注意。\n取得token 如馬賽克處，是使用機器人時所要提供給api的token。 參考 官方文件\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-telegram.bot%E5%89%8D%E7%BD%AE%E4%BD%9C%E6%A5%AD/","summary":"目的 在使用telegram機器人時，需要先在telegram新增要使用的機器人。\n搜尋 搜尋@botfather 開始 點擊start 輸入/newbot指令 輸入/newbot指令後，對話欄會請你輸入你的名稱。 設定聊天機器人的顯示名稱 這邊所輸入的名稱，並沒有限制要Bot或_bot當結尾。 設定機器人帳號 其他人可以透過查詢帳號找到我們所建立的機器人。\n當要輸入機器人帳號時，會限制要Bot或_bot結尾，需要特別注意。\n取得token 如馬賽克處，是使用機器人時所要提供給api的token。 參考 官方文件","title":"dotnet6 Telegram.Bot前置作業"},{"content":"目的 快速且簡單的製造假資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝\nBogus 編輯WeatherForecastController檔案 將預設的API註解 //除了using Bogus外，需注意需要using static Bogus.DataSets.Name，為了取得Gender using static Bogus.DataSets.Name; [HttpGet(\u0026#34;Test\u0026#34;)] public List\u0026lt;User\u0026gt; Test() { //可限制隨機值為定值 //Randomizer.Seed = new Random(8675307); //建立一個假的貨品陣列 var fruit = new[] { \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;kiwi\u0026#34; }; //預設訂單編號為0 var orderIds = 0; //預設取得英文資料 var testOrders = new Faker\u0026lt;Order\u0026gt;() //強制所有屬性都要有規則存在，預設為false .StrictMode(true) //OrderId is deterministic .RuleFor(o =\u0026gt; o.OrderId, f =\u0026gt; orderIds++) //從自訂陣列隨機取值 .RuleFor(o =\u0026gt; o.Item, f =\u0026gt; f.PickRandom(fruit)) //從1-10隨機取值 .RuleFor(o =\u0026gt; o.Quantity, f =\u0026gt; f.Random.Number(1, 10)) //從1-100隨機取值，並有20%機會為NULL .RuleFor(o =\u0026gt; o.LotNumber, f =\u0026gt; f.Random.Int(0, 100).OrNull(f, .2f)); //預設使用者編號為0 var userIds = 0; var testUsers = new Faker\u0026lt;User\u0026gt;() //使用需要初始化的類別 .CustomInstantiator(f =\u0026gt; new User(userIds++, f.Random.Replace(\u0026#34;(##)###-####\u0026#34;))) //從列舉中隨機取值(Gender為Bogus內建) .RuleFor(u =\u0026gt; u.Gender, f =\u0026gt; f.PickRandom\u0026lt;Gender\u0026gt;()) //使用內建的生成器 .RuleFor(u =\u0026gt; u.FirstName, (f, u) =\u0026gt; f.Name.FirstName(u.Gender)) .RuleFor(u =\u0026gt; u.LastName, (f, u) =\u0026gt; f.Name.LastName(u.Gender)) .RuleFor(u =\u0026gt; u.Avatar, f =\u0026gt; f.Internet.Avatar()) .RuleFor(u =\u0026gt; u.UserName, (f, u) =\u0026gt; f.Internet.UserName(u.FirstName, u.LastName)) .RuleFor(u =\u0026gt; u.Email, (f, u) =\u0026gt; f.Internet.Email(u.FirstName, u.LastName)) .RuleFor(u =\u0026gt; u.SomethingUnique, f =\u0026gt; $\u0026#34;Value {f.UniqueIndex}\u0026#34;) //可使用非Bogus的方法，建立一個新的GUID .RuleFor(u =\u0026gt; u.CartId, f =\u0026gt; Guid.NewGuid()) //可使用複合屬性 .RuleFor(u =\u0026gt; u.FullName, (f, u) =\u0026gt; $\u0026#34;{u.FirstName} {u.LastName}\u0026#34;) //複雜的集合也可以使用，並重複產生5個訂單的陣列 .RuleFor(u =\u0026gt; u.Orders, f =\u0026gt; testOrders.Generate(5).ToList()) //最後結束後可以執行特定動作 .FinishWith((f, u) =\u0026gt; { Console.WriteLine(\u0026#34;User Created! Id={0}\u0026#34;, u.Id); }); //產生3個使用者 var user = testUsers.Generate(3); return user; } public class User { public User(int v1, string v2) { Id = v1; SSN = v2; } public int Id { get; set; } public Gender Gender { get; set; } public string SSN { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Avatar { get; set; } public string UserName { get; set; } public string Email { get; set; } public string SomethingUnique { get; set; } public Guid CartId { get; set; } public string FullName { get; set; } public List\u0026lt;Order\u0026gt; Orders { get; set; } } public class Order { public int OrderId { get; set; } public string Item { get; set; } public int Quantity { get; set; } public int? LotNumber { get; set; } } 執行結果 F5執行後，依照下列步驟操作，並確認結果 參考 kinanson的技術回憶 參考\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-bogus%E7%AF%84%E4%BE%8B/","summary":"目的 快速且簡單的製造假資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝\nBogus 編輯WeatherForecastController檔案 將預設的API註解 //除了using Bogus外，需注意需要using static Bogus.DataSets.Name，為了取得Gender using static Bogus.DataSets.Name; [HttpGet(\u0026#34;Test\u0026#34;)] public List\u0026lt;User\u0026gt; Test() { //可限制隨機值為定值 //Randomizer.Seed = new Random(8675307); //建立一個假的貨品陣列 var fruit = new[] { \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;kiwi\u0026#34; }; //預設訂單編號為0 var orderIds = 0; //預設取得英文資料 var testOrders = new Faker\u0026lt;Order\u0026gt;() //強制所有屬性都要有規則存在，預設為false .StrictMode(true) //OrderId is deterministic .RuleFor(o =\u0026gt; o.OrderId, f =\u0026gt; orderIds++) //從自訂陣列隨機取值 .RuleFor(o =\u0026gt; o.Item, f =\u0026gt; f.","title":"dotnet6 Bogus範例"},{"content":"目的 批次註冊\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 新增類別檔 新增之後需要來描述要批次注入的規則\n加入前 加入後 並且繼承autofac的類別Module 編輯Program.cs檔案 //初始化並建立一個實例 builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory()); //註冊autofac這個容器 builder.Host.ConfigureContainer\u0026lt;ContainerBuilder\u0026gt;(builder =\u0026gt; builder.RegisterModule(new AutofacModuleRegister())); 有繼承autofac的類別Module 新增資料夾 新增下圖兩個資料夾 新增類別檔 此次的目的是要可以進行批次注入，所以檔名結尾都需要包含Service，做批次注入時可以辨識\n在Services資料夾底下加入類別檔案，名稱為TestService 在Interface資料夾底下加入介面檔案，名稱為ITest ITest.cs寫入程式 namespace AutoFacExample.Services.Interface { public interface ITest { public string GetName(string id); } } TestService.cs寫入程式 繼承介面後寫上與介面相同的方法 using AutoFacExample.Services.Interface; namespace AutoFacExample.Services { public class TestService : ITest { public string GetName(string id) { return $\u0026#34;{id}:Bill\u0026#34;; } } } AutofacModuleRegister執行批次註冊 protected override void Load(ContainerBuilder builder) { //RegisterAssemblyTypes =\u0026gt; 註冊所有集合 //Where(t =\u0026gt; t.Name.EndsWith(\u0026#34;Service\u0026#34;)) =\u0026gt; 找出所有Service結尾的檔案 //AsImplementedInterfaces =\u0026gt; 找到Service後註冊到其所繼承的介面 builder.RegisterAssemblyTypes(typeof(Program).Assembly) .Where(t =\u0026gt; t.Name.EndsWith(\u0026#34;Service\u0026#34;)) .AsImplementedInterfaces(); } 新增測試用controller TestController.cs寫入程式 using AutoFacExample.Services.Interface; using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; namespace AutoFacExample.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class TestController : ControllerBase { //為隱私修飾詞並且唯讀 private readonly ITest _test; //在建構子時注入需要使用的服務 public TestController(ITest test) { _test = test; } [HttpGet(\u0026#34;GetName\u0026#34;)] public string Get(string id) { //使用注入的服務 return _test.GetName(id); } } } 注入的服務都是使用介面，目的是之後方便抽換，才可以進行測試 命名原則都會加一個底線代表全域變數 執行結果 最終確認程式是可執行，就沒有問題了。 參考 .net6註冊autofac說明文件 參考文件 參考文件 參考文件\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-autofac%E7%AF%84%E4%BE%8B/","summary":"目的 批次註冊\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 新增類別檔 新增之後需要來描述要批次注入的規則\n加入前 加入後 並且繼承autofac的類別Module 編輯Program.cs檔案 //初始化並建立一個實例 builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory()); //註冊autofac這個容器 builder.Host.ConfigureContainer\u0026lt;ContainerBuilder\u0026gt;(builder =\u0026gt; builder.RegisterModule(new AutofacModuleRegister())); 有繼承autofac的類別Module 新增資料夾 新增下圖兩個資料夾 新增類別檔 此次的目的是要可以進行批次注入，所以檔名結尾都需要包含Service，做批次注入時可以辨識\n在Services資料夾底下加入類別檔案，名稱為TestService 在Interface資料夾底下加入介面檔案，名稱為ITest ITest.cs寫入程式 namespace AutoFacExample.Services.Interface { public interface ITest { public string GetName(string id); } } TestService.cs寫入程式 繼承介面後寫上與介面相同的方法 using AutoFacExample.Services.Interface; namespace AutoFacExample.Services { public class TestService : ITest { public string GetName(string id) { return $\u0026#34;{id}:Bill\u0026#34;; } } } AutofacModuleRegister執行批次註冊 protected override void Load(ContainerBuilder builder) { //RegisterAssemblyTypes =\u0026gt; 註冊所有集合 //Where(t =\u0026gt; t.","title":"dotnet6 Autofac範例"},{"content":"目的 快速測試不同寫法的效能差異。\n建立新專案 選擇主控台應用程式專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 下載BenchmarkDotNet套件與automapper套件，automapper為這次要測試效能的套件 Program寫入程式 此次要測試的項目為三種類別轉換的效能差異\nusing AutoMapper; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; //指定要測試的class var summary = BenchmarkRunner.Run\u0026lt;BenchmarkSampleAuto\u0026gt;(); //加入記憶體使用量測試 [MemoryDiagnoser] public class BenchmarkSampleAuto { private readonly List\u0026lt;DbModel\u0026gt; _data = new List\u0026lt;DbModel\u0026gt;(); private readonly IMapper _mapper; public BenchmarkSampleAuto() { //automapper設定 var config = new MapperConfiguration(cfg =\u0026gt; { cfg.CreateMap\u0026lt;DbModel, ViewModel\u0026gt;(); }); _mapper = new Mapper(config); //準備一份List資料 PrepareTestObjects(); } private void PrepareTestObjects() { _data.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill\u0026#34;, Age = 18, CreatedDate = DateTime.Now }); _data.Add(new DbModel() { Id = 1, Name = \u0026#34;CI-YU\u0026#34;, Age = 20, CreatedDate = DateTime.Now }); _data.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill Huang\u0026#34;, Age = 22, CreatedDate = DateTime.Now }); } //待測方法需要加上Benchmark屬性 [Benchmark] public List\u0026lt;ViewModel\u0026gt; first() { return _mapper.Map\u0026lt;List\u0026lt;ViewModel\u0026gt;\u0026gt;(_data); } //待測方法需要加上Benchmark屬性 [Benchmark] public List\u0026lt;ViewModel\u0026gt; second() { var listModel = new List\u0026lt;ViewModel\u0026gt;(); foreach (var c in _data) { listModel.Add(new ViewModel() { Id = c.Id, Name = c.Name, Age = c.Age }); } return listModel; } //待測方法需要加上Benchmark屬性 [Benchmark] public List\u0026lt;ViewModel\u0026gt; third() { var listModel = new List\u0026lt;ViewModel\u0026gt;(); listModel = _data.Select(c =\u0026gt; new ViewModel() { Id = c.Id, Name = c.Name, Age = c.Age }).ToList(); return listModel; } } public class DbModel { public int Id { get; set; } public string? Name { get; set; } public int Age { get; set; } public DateTime CreatedDate { get; set; } } public class ViewModel { public ViewModel() { Name = string.Empty; } public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } 執行測試 執行測試前需要將組態改為Release才可以進行測試\n執行結果 最後的執行結果發現第二種方法的效能是最好的，通常最主要是看mean及allocated兩個參數\nMean 平均時間 Allocated 記憶體使用量 補充 在專案資料夾bin\\Release\\net6.0\\BenchmarkDotNet.Artifacts\\results底下會有詳細的報告，檔案格式有csv,html,md\n參考資料 參考 伊果的沒人看筆記本\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-benchmarkdotnet%E7%AF%84%E4%BE%8B/","summary":"目的 快速測試不同寫法的效能差異。\n建立新專案 選擇主控台應用程式專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步\nNuGet加入套件 下載BenchmarkDotNet套件與automapper套件，automapper為這次要測試效能的套件 Program寫入程式 此次要測試的項目為三種類別轉換的效能差異\nusing AutoMapper; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; //指定要測試的class var summary = BenchmarkRunner.Run\u0026lt;BenchmarkSampleAuto\u0026gt;(); //加入記憶體使用量測試 [MemoryDiagnoser] public class BenchmarkSampleAuto { private readonly List\u0026lt;DbModel\u0026gt; _data = new List\u0026lt;DbModel\u0026gt;(); private readonly IMapper _mapper; public BenchmarkSampleAuto() { //automapper設定 var config = new MapperConfiguration(cfg =\u0026gt; { cfg.CreateMap\u0026lt;DbModel, ViewModel\u0026gt;(); }); _mapper = new Mapper(config); //準備一份List資料 PrepareTestObjects(); } private void PrepareTestObjects() { _data.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill\u0026#34;, Age = 18, CreatedDate = DateTime.","title":"dotnet6 BenchmarkDotNet範例"},{"content":"目的 快速對應，不需要寫linq來將資料庫端的model對應到view要用的model\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝AutoMapper.Extensions.Microsoft.DependencyInjection 編輯Program.cs檔案 註冊AutoMapper\n//找到所有繼承profile builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies()); 新增Mappings資料夾與Models資料夾 在Models資料夾內加入DbModel資料夾與ViewModel資料夾 加入類別檔 在兩個資料夾內加入同名稱的類別檔案 DbModel.cs寫入程式碼 public int Id { get; set; } public string? Name { get; set; } public int Age { get; set; } public DateTime CreatedDate { get; set; } 可能會有些人問?是什麼，這是因為建立.net6專案預設會開啟判斷值可能為null的警告訊息，可以加上?代表允許此屬性為null，會建議在建構子時提供預設值，來避免嘗試對null值做處理的exception。\nViewModel.cs寫入程式 public ViewModel() { Name = string.Empty; } public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } 在建構子提供預設值後，來避免對null做處理。\n加入類別檔 在Mappings資料夾內加入名稱為ExampleMapping的類別檔 寫入程式 在新增的ExampleMapping.cs檔案內寫入程式碼 using AutoMapper; using AutoMapperExample.Models.DbModel; using AutoMapperExample.Models.ViewModel; namespace AutoMapperExample.Mappings { //需要繼承AutoMapper的Profile public class ExampleMapping : Profile { public ExampleMapping() { //來源與目標=\u0026gt;白話文是我要將DbModel對應到ViewModel CreateMap\u0026lt;DbModel, ViewModel\u0026gt;(); } } } 加入檔案 在Controllers加入一個空白的API控制器，並命名為ExampleController.cs 寫入程式 using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; using AutoMapperExample.Models.DbModel; using AutoMapperExample.Models.ViewModel; using AutoMapper; namespace AutoMapperExample.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class ExampleController : ControllerBase { private readonly IMapper _mapper; public ExampleController(IMapper mapper) { _mapper = mapper; } [HttpGet(\u0026#34;Index\u0026#34;)] public IEnumerable\u0026lt;ViewModel\u0026gt; Index() { var DbModel = new List\u0026lt;DbModel\u0026gt;(); //新增DbModel的List模擬從資料庫來的資料 DbModel.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill\u0026#34;, Age = 18, CreatedDate = DateTime.Now }); DbModel.Add(new DbModel() { Id = 1, Name = \u0026#34;CI-YU\u0026#34;, Age = 20, CreatedDate = DateTime.Now }); DbModel.Add(new DbModel() { Id = 1, Name = \u0026#34;Bill Huang\u0026#34;, Age = 22, CreatedDate = DateTime.Now }); //將DbModel資料自動與ViewModel做對應(相同名稱的屬性) var map = _mapper.Map\u0026lt;IEnumerable\u0026lt;ViewModel\u0026gt;\u0026gt;(DbModel); return map; } } } 執行結果 可以自動對應到結果了。 範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-automapper%E7%AF%84%E4%BE%8B/","summary":"目的 快速對應，不需要寫linq來將資料庫端的model對應到view要用的model\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 透過NuGet安裝AutoMapper.Extensions.Microsoft.DependencyInjection 編輯Program.cs檔案 註冊AutoMapper\n//找到所有繼承profile builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies()); 新增Mappings資料夾與Models資料夾 在Models資料夾內加入DbModel資料夾與ViewModel資料夾 加入類別檔 在兩個資料夾內加入同名稱的類別檔案 DbModel.cs寫入程式碼 public int Id { get; set; } public string? Name { get; set; } public int Age { get; set; } public DateTime CreatedDate { get; set; } 可能會有些人問?是什麼，這是因為建立.net6專案預設會開啟判斷值可能為null的警告訊息，可以加上?代表允許此屬性為null，會建議在建構子時提供預設值，來避免嘗試對null值做處理的exception。\nViewModel.cs寫入程式 public ViewModel() { Name = string.Empty; } public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } 在建構子提供預設值後，來避免對null做處理。","title":"dotnet6 Automapper範例"},{"content":"目的 使用gmail寄信\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Google.Apis.Auth(使用google信箱時需要做oauth驗證才可以使用) MailKit(寄信) 編輯WeatherForecastController檔案 將預設的API註解 [HttpGet(\u0026#34;SendEmail\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get() { #region OAuth驗證 const string GMailAccount = \u0026#34;前置作業文章打上去的測試帳號\u0026#34;; var clientSecrets = new ClientSecrets { ClientId = \u0026#34;前置作業文章最後給的用戶ID\u0026#34;, ClientSecret = \u0026#34;前置作業文章最後給的用戶端密碼\u0026#34; }; var codeFlow = new GoogleAuthorizationCodeFlow(new GoogleAuthorizationCodeFlow.Initializer { DataStore = new FileDataStore(\u0026#34;CredentialCacheFolder\u0026#34;, false), Scopes = new[] { \u0026#34;https://mail.google.com/\u0026#34; }, ClientSecrets = clientSecrets }); var codeReceiver = new LocalServerCodeReceiver(); var authCode = new AuthorizationCodeInstalledApp(codeFlow, codeReceiver); var credential = await authCode.AuthorizeAsync(GMailAccount, CancellationToken.None); if (credential.Token.IsExpired(SystemClock.Default)) await credential.RefreshTokenAsync(CancellationToken.None); var oauth2 = new SaslMechanismOAuth2(credential.UserId, credential.Token.AccessToken); #endregion #region 信件內容 var message = new MimeMessage(); //寄件者名稱及信箱(信箱是測試帳號) message.From.Add(new MailboxAddress(\u0026#34;bill\u0026#34;, \u0026#34;xxxx@gmail.com\u0026#34;)); //收件者名稱，收件者信箱 message.To.Add(new MailboxAddress(\u0026#34;billhuang\u0026#34;, \u0026#34;xxxx@gmail.com\u0026#34;)); //信件標題 message.Subject = \u0026#34;How you doing\u0026#39;?\u0026#34;; //信件內容 message.Body = new TextPart(\u0026#34;plain\u0026#34;) { Text = @\u0026#34;This is test\u0026#34; }; using (var client = new SmtpClient()) { await client.ConnectAsync(\u0026#34;smtp.gmail.com\u0026#34;, 587); await client.AuthenticateAsync(oauth2); await client.SendAsync(message); await client.DisconnectAsync(true); } #endregion return Ok(\u0026#34;OK\u0026#34;); } 執行結果 F5執行後，依照下列步驟操作，最後看到OK後，就可以去信箱確認有沒有收到信了。 MailKit為基於MimeKit解析器的客戶端函式庫 MimeKit為解析器，用於解析電子郵件格式\n參考 官方網站 官方GmailOauth2範例 Gmail教學\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-mailkit%E7%AF%84%E4%BE%8B/","summary":"目的 使用gmail寄信\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 NuGet加入套件 Google.Apis.Auth(使用google信箱時需要做oauth驗證才可以使用) MailKit(寄信) 編輯WeatherForecastController檔案 將預設的API註解 [HttpGet(\u0026#34;SendEmail\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get() { #region OAuth驗證 const string GMailAccount = \u0026#34;前置作業文章打上去的測試帳號\u0026#34;; var clientSecrets = new ClientSecrets { ClientId = \u0026#34;前置作業文章最後給的用戶ID\u0026#34;, ClientSecret = \u0026#34;前置作業文章最後給的用戶端密碼\u0026#34; }; var codeFlow = new GoogleAuthorizationCodeFlow(new GoogleAuthorizationCodeFlow.Initializer { DataStore = new FileDataStore(\u0026#34;CredentialCacheFolder\u0026#34;, false), Scopes = new[] { \u0026#34;https://mail.google.com/\u0026#34; }, ClientSecrets = clientSecrets }); var codeReceiver = new LocalServerCodeReceiver(); var authCode = new AuthorizationCodeInstalledApp(codeFlow, codeReceiver); var credential = await authCode.","title":"dotnet6 MailKit範例"},{"content":"目的 前往google帳號設定OAuth，才能使用google帳號寄信\n點擊連結 到 google帳號管理\n新增專案 點擊如圖按鈕建立新專案 命名你的專案名稱，並點擊建立 設定OAuth 跟著紅框處點擊到OAuth同意畫面 點擊剛剛建立的專案 選擇外部，並點擊建立 編輯應用程式註冊申請畫面 將所有必填欄位填完 第二步直接下一步 新增使用者，要建立你要使用的帳號 摘要直接下一步 憑證 點建立憑證 點擊OAuth用戶端ID 應用程式類型選擇電腦版應用程式，填入名稱後點擊建立 最後會取得用戶端ID與用戶端密碼 結論 最後就可以進行MailKit的使用了，下一篇就可以使用ＭailKit\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-mailkit%E5%89%8D%E7%BD%AE%E4%BD%9C%E6%A5%AD/","summary":"目的 前往google帳號設定OAuth，才能使用google帳號寄信\n點擊連結 到 google帳號管理\n新增專案 點擊如圖按鈕建立新專案 命名你的專案名稱，並點擊建立 設定OAuth 跟著紅框處點擊到OAuth同意畫面 點擊剛剛建立的專案 選擇外部，並點擊建立 編輯應用程式註冊申請畫面 將所有必填欄位填完 第二步直接下一步 新增使用者，要建立你要使用的帳號 摘要直接下一步 憑證 點建立憑證 點擊OAuth用戶端ID 應用程式類型選擇電腦版應用程式，填入名稱後點擊建立 最後會取得用戶端ID與用戶端密碼 結論 最後就可以進行MailKit的使用了，下一篇就可以使用ＭailKit","title":"dotnet6 MailKit前置作業"},{"content":"目的 透過強行別的模式使用appsetting設定檔資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 設定appsetting檔案 在appsetting新增一筆json資料\n\u0026#34;PersonalInformation\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;Bill\u0026#34;, \u0026#34;Age\u0026#34;: 20 } 新增model資料夾，並在裡面新增AppsettingConfig類別檔 編輯AppsettingConfig類別檔案 public class PersonalInformation { public PersonalInformation() { Name = string.Empty; } public string Name { get; set; } public int Age { get; set; } } 編輯Program.cs檔案 在program.cs中把appsetting的來源綁定在PersonalInformation這個class上\nbuilder.Services.Configure\u0026lt;PersonalInformation\u0026gt;( builder.Configuration.GetSection(\u0026#34;PersonalInformation\u0026#34;)); 注入所需要的地方 注入到預設的WeatherForecastController中，就可以使用。\nprivate readonly PersonalInformation _options; public WeatherForecastController(ILogger\u0026lt;WeatherForecastController\u0026gt; logger, IOptionsMonitor\u0026lt;PersonalInformation\u0026gt; options) { _logger = logger; _options = options.CurrentValue; } 此範例使用的是IOptionsMonitor\n選項模式 可使用singleton 重載 具名選項 IOptions V X X IOptionsSnapshot X V V IOptionsMonitor V V V 參考 選項模式 IOptions與IOptionsSnaphot與IOptionsMonitor 程式範例參考 options差別\n範例檔 GitHub\n","permalink":"http://localhost:1313/dotnet/%E9%90%B5%E4%BA%BA%E8%B3%BD-net6-%E5%8F%96%E5%BE%97appsettings%E6%AA%94%E6%A1%88/","summary":"目的 透過強行別的模式使用appsetting設定檔資料\n建立新專案 選擇ASP.NET Core Web API專案範本，並執行下一步 設定新的專案 命名你的專案名稱，並選擇專案要存放的位置。 其他資訊 直接進行下一步 設定appsetting檔案 在appsetting新增一筆json資料\n\u0026#34;PersonalInformation\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;Bill\u0026#34;, \u0026#34;Age\u0026#34;: 20 } 新增model資料夾，並在裡面新增AppsettingConfig類別檔 編輯AppsettingConfig類別檔案 public class PersonalInformation { public PersonalInformation() { Name = string.Empty; } public string Name { get; set; } public int Age { get; set; } } 編輯Program.cs檔案 在program.cs中把appsetting的來源綁定在PersonalInformation這個class上\nbuilder.Services.Configure\u0026lt;PersonalInformation\u0026gt;( builder.Configuration.GetSection(\u0026#34;PersonalInformation\u0026#34;)); 注入所需要的地方 注入到預設的WeatherForecastController中，就可以使用。\nprivate readonly PersonalInformation _options; public WeatherForecastController(ILogger\u0026lt;WeatherForecastController\u0026gt; logger, IOptionsMonitor\u0026lt;PersonalInformation\u0026gt; options) { _logger = logger; _options = options.CurrentValue; } 此範例使用的是IOptionsMonitor","title":"dotnet6 取得appsettings檔案內容"}]